/**
 * Copyright (C) 2014 BigLoupe http://bigloupe.github.io/SoS-JobScheduler/
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License
 */
/********************************************************* begin of preamble
**
** Copyright (C) 2003-2012 Software- und Organisations-Service GmbH. 
** All rights reserved.
**
** This file may be used under the terms of either the 
**
**   GNU General Public License version 2.0 (GPL)
**
**   as published by the Free Software Foundation
**   http://www.gnu.org/licenses/gpl-2.0.txt and appearing in the file
**   LICENSE.GPL included in the packaging of this file. 
**
** or the
**  
**   Agreement for Purchase and Licensing
**
**   as offered by Software- und Organisations-Service GmbH
**   in the respective terms of supply that ship with this file.
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
** IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
** THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
** PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
** BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
** CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
** SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
** INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
** CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
** ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
** POSSIBILITY OF SUCH DAMAGE.
********************************************************** end of preamble*/
package com.sos.scheduler.history;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

import org.joda.time.DateTime;

 
import com.sos.dashboard.globals.DashBoardConstants;
import com.sos.hibernate.classes.DbItem;
import com.sos.hibernate.classes.SOSHibernateIntervalFilter;
import com.sos.hibernate.classes.UtcTimeHelper;
import com.sos.hibernate.interfaces.ISOSHibernateFilter;
import com.sos.scheduler.history.classes.SOSIgnoreList;

/**
 * \class SchedulerHistoryFilter
 *
 * \brief SchedulerHistoryFilter -
 *
 * \details
 *
 * \section SchedulerHistoryFilter.java_intro_sec Introduction
 *
 * \section SchedulerHistoryFilter.java_samples Some Samples
 *
 * \code .... code goes here ... \endcode
 *
 * <p style="text-align:center">
 * <br />
 * --------------------------------------------------------------------------- <br />
 * APL/Software GmbH - Berlin <br />
 * ##### generated by ClaviusXPress (http://www.sos-berlin.com) ######### <br />
 * ---------------------------------------------------------------------------
 * </p>
 * \author Uwe Risse \version 14.12.2011 \see reference
 *
 * Created on 14.12.2011 13:53:37
 */

public class SchedulerHistoryFilter extends SOSHibernateIntervalFilter implements ISOSHibernateFilter {

	@SuppressWarnings("unused")
	private final String	conClassName	= "SchedulerHistoryFilter";
	private String			dateFormat		= "yyyy-MM-dd HH:mm:ss";
	private Date			executedFrom;
	private Date			executedTo;
	private Date			startTime;
	private Date			endTime;
	private String			schedulerId		= "";
	private boolean			showWithError	= false;
	private boolean			showRunning  	= false;
	private boolean			showSuccessfull	= false;
	private String			executedFromIso	= null;
	private String			executedToIso	= null;
	private SOSIgnoreList	ignoreList		= null;
	protected String		searchField		= null;

	private boolean			showJobs		= true;
	private boolean			showJobChains	= true;

	public String getSearchField() {
		return searchField;
	}

	public void setSearchField(final String searchField) {
		this.searchField = searchField;
	}

	public SchedulerHistoryFilter() {
		super(DashBoardConstants.conPropertiesFileName);
		ignoreList = new SOSIgnoreList();
	}

	public boolean isShowJobs() {
		return showJobs;
	}

	public void setShowJobs(final boolean  showJobs) {
		this.showJobs = showJobs;
	}

	public boolean isShowJobChains() {
		return showJobChains;
	}

	public void setShowJobChains(final boolean showJobChains) {
		this.showJobChains = showJobChains;
	}

	public String getExecutedFromIso() {
		return executedFromIso;
	}

	public void setExecutedFromIso(final String executedFromIso) {
		this.executedFromIso = executedFromIso;
	}

	public String getExecutedToIso() {
		return executedToIso;
	}

	public void setExecutedToIso(final String executedToIso) {
		this.executedToIso = executedToIso;
	}

	public SOSIgnoreList getIgnoreList() {
		return ignoreList;
	}

	@Override
	public String getDateFormat() {
		return dateFormat;
	}

	@Override
	public void setDateFormat(final String dateFormat) {
		this.dateFormat = dateFormat;
	}

	public Date getExecutedUtcFrom() {
       return UtcTimeHelper.convertTimeZonesToDate(UtcTimeHelper.localTimeZoneString(), "UTC", new DateTime(executedFrom));

	}

	public void setExecutedFrom(final String executedFrom) throws ParseException {
		if (executedFrom.equals("")) {
			this.executedFrom = null;
		}
		else {
			SimpleDateFormat formatter = new SimpleDateFormat(dateFormat);
			Date d = formatter.parse(executedFrom);
			setExecutedFrom(d);
		}
	}

	public Date getExecutedUtcTo() {
       return UtcTimeHelper.convertTimeZonesToDate(UtcTimeHelper.localTimeZoneString(), "UTC", new DateTime(executedTo));
	}

	public void setExecutedTo(final String executedTo) throws ParseException {
		if (executedTo.equals("")) {
			this.executedTo = null;
		}
		else {
			SimpleDateFormat formatter = new SimpleDateFormat(dateFormat);
			Date d = formatter.parse(executedTo);
			setExecutedTo(d);
		}
	}

	public String getSchedulerId() {
		return schedulerId;
	}

	public void setSchedulerId(final String schedulerId) {
		this.schedulerId = schedulerId;
	}

	public void setExecutedFrom(final Date from) {
		SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd 00:00:00");
		String d = formatter.format(from);
		try {
			formatter = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
			executedFrom = formatter.parse(d);
		}
		catch (ParseException e) {
			e.printStackTrace();
		}

		formatter = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		executedFromIso = formatter.format(from);
	}

	public void setExecutedTo(final Date to) {
		SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd 23:59:59");
		String d = formatter.format(to);
		try {
			formatter = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
			executedTo = formatter.parse(d);
		}
		catch (ParseException e) {
			e.printStackTrace();
		}

		formatter = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		executedToIso = formatter.format(to);
	}

	public void setStartTime(final Date start) {
		startTime = start;
	}

	public void setEndTime(final Date end) {
		endTime = end;
	}

	public Date getStartTime() {
		return startTime;
	}

	public Date getEndTime() {
		return endTime;
	}

	@Override
	public String getTitle() {
		String ignoreList = " ";
		int ignoreOrderCount = getIgnoreList().size();
		int ignoreJobCount = getIgnoreList().size();
		if (ignoreOrderCount > 0 || ignoreJobCount > 0) {
			ignoreList = String.format("%1s Jobs %2s Orders ignored", ignoreJobCount, ignoreOrderCount);
		}

		String s = "";
		if (schedulerId != null && !schedulerId.equals("")) {
			s += String.format("Id: %s ", schedulerId);
		}


		if (executedFrom != null) {
			s += String.format(Messages.getLabel(DashBoardConstants.conSOSDashB_FROM) + ": %s ", date2Iso(executedFrom));
		}
		if (executedTo != null) {
			s += String.format(Messages.getLabel(DashBoardConstants.conSOSDashB_TO) + ": %s ", date2Iso(executedTo));
		}
		if (showJobs) {
			s += " " + String.format(Messages.getLabel(DashBoardConstants.conSOSDashB_JOBS));
		}
		if (showJobChains) {
			s += " " + String.format(Messages.getLabel(DashBoardConstants.conSOSDashB_JOBCHAINS));
		}

		if (showWithError) {
			s += " " + String.format(Messages.getLabel(DashBoardConstants.conSOSDashB_show_with_error));
		}
		if (showRunning) {
			s += " " + String.format(Messages.getLabel(DashBoardConstants.conSOSDashB_show_running));
		}

		if (showSuccessfull) {
			s += " " + String.format(Messages.getLabel(DashBoardConstants.conSOSDashB_show_successfull));
		}

		if (searchField != null) {
			s += searchField;
		}

		String title = String.format("%1s %2s ", s, ignoreList);
		return title;
	}

	@Override
	public boolean isFiltered(final DbItem h) {
		return false;
	}

	public void setShowWithError(final boolean showWithError) {
		this.showWithError = showWithError;
	}

	public boolean isShowWithError() {
		return showWithError;
	}

	@Override
	public void setIntervalFromDate(Date d) {
	   this.executedFrom = d;
	}

	@Override
	public void setIntervalToDate(Date d) {
	   this.executedTo = d;
	}

	@Override
	public void setIntervalFromDateIso(String s) {
		   this.executedFromIso = s;
	}

	@Override
	public void setIntervalToDateIso(String s) {
		   this.executedToIso = s;
	}

	public void setShowRunning(boolean showRunning) {
		this.showRunning = showRunning;
	}

	public boolean isShowRunning() {
		return showRunning;
	}

	public boolean isShowSuccessfull() {
		return showSuccessfull;
	}

	public void setShowSuccessfull(boolean showSuccessfull) {
		this.showSuccessfull = showSuccessfull;
	}

}
