/**
 * Copyright (C) 2014 BigLoupe http://bigloupe.github.io/SoS-JobScheduler/
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License
 */
/********************************************************* begin of preamble
**
** Copyright (C) 2003-2012 Software- und Organisations-Service GmbH. 
** All rights reserved.
**
** This file may be used under the terms of either the 
**
**   GNU General Public License version 2.0 (GPL)
**
**   as published by the Free Software Foundation
**   http://www.gnu.org/licenses/gpl-2.0.txt and appearing in the file
**   LICENSE.GPL included in the packaging of this file. 
**
** or the
**  
**   Agreement for Purchase and Licensing
**
**   as offered by Software- und Organisations-Service GmbH
**   in the respective terms of supply that ship with this file.
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
** IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
** THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
** PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
** BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
** CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
** SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
** INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
** CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
** ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
** POSSIBILITY OF SUCH DAMAGE.
********************************************************** end of preamble*/
package com.sos.scheduler.model.objects;
import java.io.File;
import java.io.InputStream;
import java.lang.reflect.Field;
import java.math.BigInteger;

import javax.xml.bind.JAXBElement;
import javax.xml.bind.annotation.XmlTransient;

import org.apache.log4j.Logger;

import com.sos.JSHelper.Exceptions.JobSchedulerException;
import com.sos.VirtualFileSystem.Interfaces.ISOSVirtualFile;
import com.sos.scheduler.model.SchedulerHotFolder;
import com.sos.scheduler.model.SchedulerObjectFactory;

/**
* \class JSObjBase
*
* \brief JSObjBase -
*
* \details
*
* \code
*   .... code goes here ...
* \endcode
*
* <p style="text-align:center">
* <br />---------------------------------------------------------------------------
* <br /> APL/Software GmbH - Berlin
* <br />##### generated by ClaviusXPress (http://www.sos-berlin.com) #########
* <br />---------------------------------------------------------------------------
* </p>
* \author oh
* @version $Id: JSObjBase.java 20893 2013-08-21 16:39:36Z kb $
* \see reference
*
* Created on 03.02.2011 16:06:55
 */
public class JSObjBase implements Comparable<JSObjBase> {
	private final String				conClassName			= "JSObjBase";
	private static final Logger			logger					= Logger.getLogger(JSObjBase.class);

	protected static final String		conEMPTY				= "";
	protected static final String		conNO					= "no";
	protected static final String		conYES					= "yes";

	protected SchedulerObjectFactory	objFactory				= null;
	private ISOSVirtualFile				hotFolderSrc			= null;
	protected JAXBElement<JSObjBase>	objJAXBElement			= null;
	@XmlTransient
	private boolean						flgIsDirty				= false;

	protected String					strFileNameExtension	= "";
	protected ISOSVirtualFile			objVirtualFile			= null;

	protected boolean					flgIsInit				= false;

	@XmlTransient
	public void setInit(final boolean flgF) {

		@SuppressWarnings("unused")
		final String conMethodName = conClassName + "::setInit";

		flgIsInit = flgF;

	} // private void setDirty

	//	@XmlTransient
	public boolean canUpdate() {
		return flgIsInit == false;
	}

	@XmlTransient
	public void setDirty(final boolean flgF) {

		@SuppressWarnings("unused")
		final String conMethodName = conClassName + "::setDirty";

		flgIsDirty = flgF;

	} // private void setDirty

	public void setDirty() {

		@SuppressWarnings("unused")
		final String conMethodName = conClassName + "::setDirty";

		flgIsDirty = true;

	} // private void setDirty

	public boolean isDirty() {

		@SuppressWarnings("unused")
		final String conMethodName = conClassName + "::isDirty";

		return flgIsDirty;

	} // private boolean isDirty

	public JSObjBase() {
		//
	}

	public void setParent(final SchedulerObjectFactory objParent) {
		@SuppressWarnings("unused")
		final String conMethodName = conClassName + "::setParent";
		objFactory = objParent;
	} // private void setParent

	public Object unMarshal(final File pobjFile) {
		return objFactory.unMarshall(pobjFile);
	}

	public Object unMarshal(final InputStream pobjInputStream) {
		return objFactory.unMarshall(pobjInputStream);
	}

	public Object unMarshal(final String pobjString) {
		return objFactory.unMarshall(pobjString);
	}

	public Object unMarshal(final ISOSVirtualFile pobjVirtualFile) {
		return objFactory.unMarshall(pobjVirtualFile);
	}

	public Object marshal(final Object objO, final File objF) {
		return objFactory.marshal(objO, objF);
	}

	public Object marshal(final File objF) {
		Object objO = null;
		if (objJAXBElement == null) {
			objO = this;
		}
		else {
			objJAXBElement.setValue(this);
			objO = objJAXBElement;
		}
		return marshal(objO, objF);
	}

	public String marshal() {
		Object objO = null;
		if (objJAXBElement == null) {
			objO = this;
		}
		else {
			objJAXBElement.setValue(this);
			objO = objJAXBElement;
		}
		return objFactory.marshal(objO);
	}

	public Object toXMLFile(final Object objO, final ISOSVirtualFile pobjVirtualFile) {
		return objFactory.toXMLFile(objO, pobjVirtualFile);
	}

	public Object toXMLFile(final ISOSVirtualFile pobjVirtualFile) {
		Object objO = null;
		if (objJAXBElement == null) {
			objO = this;
		}
		else {
			objJAXBElement.setValue(this);
			objO = objJAXBElement;
		}
		return toXMLFile(objO, pobjVirtualFile);
	}

	public Object toXMLFile() {
		return toXMLFile(hotFolderSrc);
	}

	public String toXMLString(final Object objO) {
		return objFactory.toXMLString(objO);
	}

	public String toXMLString() {
		String xmlString = null;
		if (objJAXBElement == null) {
			xmlString = objFactory.toXMLString(this);
		}
		else {
			objJAXBElement.setValue(this);
			xmlString = objFactory.toXMLString(objJAXBElement);
		}
		return xmlString;
	}

	@XmlTransient
	public void setHotFolderSrc(final ISOSVirtualFile pobjVirtualFile) {
		hotFolderSrc = pobjVirtualFile;
	}

	public ISOSVirtualFile getHotFolderSrc() {
		return hotFolderSrc;
	}

	@Override
	public int compareTo(final JSObjBase o) {
		@SuppressWarnings("unused")
		final String conMethodName = conClassName + "::compareTo";
		int compareRet = 0;
		boolean thisIsFolder = this.getClass().getSimpleName().equals("SchedulerHotFolder");
		boolean oIsFolder = o instanceof SchedulerHotFolder;
		if (thisIsFolder && !oIsFolder) {
			compareRet = -1;
		}
		else
			if (!thisIsFolder && oIsFolder) {
				compareRet = 1;
			}
			else
				if (this.getHotFolderSrc() == null) {
					compareRet = 1;
				}
				else
					if (o.getHotFolderSrc() == null) {
						compareRet = -1;
					}
					else {
						String hotFolderSrcName1 = this.getHotFolderSrc().getName().toLowerCase();
						String hotFolderSrcName2 = o.getHotFolderSrc().getName().toLowerCase();
						compareRet = hotFolderSrcName1.compareTo(hotFolderSrcName2);
					}
		return compareRet;
	}

	/**
	 *
	 * \brief setObjectFieldsFrom
	 *
	 * \details
	 * set all fields of a subclass according to its superclass
	 *
	 * \return void
	 *
	 * @param origObj
	 */
	public void setObjectFieldsFrom(final JSObjBase origObj) {
		@SuppressWarnings("unused")
		final String conMethodName = conClassName + "::setObjectFieldsFrom";
		Field[] fields;
		Class<?> origClass = origObj.getClass();
		if (!origClass.isAssignableFrom(this.getClass())) {
			throw new JobSchedulerException(String.format("%1$s must be a subclass of %2$s", this.getClass().getName(), origClass.getName()));
		}
		fields = origClass.getDeclaredFields();
		for (Field field : fields) {
			try {
				// to see private and protected fields too
				field.setAccessible(true);
				if (field.isAccessible()) {
					// final fields couldn't set and throws IllegalAccessException
					// but that's ok because we don't want set final fields
					field.set(this, field.get(origObj));
				}
			}
			catch (IllegalArgumentException e) {
				logger.error("", new JobSchedulerException("IllegalArgumentException", e));
			}
			catch (IllegalAccessException e) {
				// this catch block is reached for final fields (that's ok)
			}
		}
	}

	public boolean getYesOrNo(final String yesOrNo) {
		if (yesOrNo != null) {
			String work = yesOrNo.toLowerCase();
			return work.equals("1") || work.equals("yes") || work.equals("true") || work.equals("ja");
		}
		return false;
	}

	public String setYesOrNo(final boolean pflgV) {
		if (pflgV == true) {
			return "yes";
		}
		else {
			return "no";
		}
	}

	public String getObjectName() {

		@SuppressWarnings("unused")
		final String conMethodName = conClassName + "::getJobName";

		String name = this.getHotFolderSrc().getName();
		int i = name.indexOf(strFileNameExtension);
		if (i != -1) {
			name = name.substring(0, name.indexOf(strFileNameExtension));
		}
		name = new File(name).getName();

		return name;

	} // private String getJobName

	public String getObjectNameAndTitle() {
		String strT = getObjectName();
		String strV = getTitle();
		if (strV != null && strV.isEmpty() == false) {
			strT += " - " + getTitle();
		}
		return strT;
	}

	public static String notNull(final String pstrS) {
		String strR = pstrS;
		if (strR == null) {
			strR = "";
		}
		return strR;
	}

	public String getTitle() {
		return "";
	}

	public boolean isEnabled() {

		@SuppressWarnings("unused")
		final String conMethodName = conClassName + "::isEnabled";

		boolean flgT = true;
		// TODO implement canWrite()
		//		boolean flgT = getHotFolderSrc().canWrite();
		return flgT;
	} // private boolean isEnabled

	protected void changeSourceName(final String pstrName) {
		ISOSVirtualFile objF = getHotFolderSrc();
		if (objF != null) {
			String name = objF.getName();
			name = name.replace(getObjectName(), pstrName);
			ISOSVirtualFile objNF = objF.getHandler().getFileHandle(name);
			setHotFolderSrc(objNF);
		}
	}

	protected String avoidNull(final String pstrV) {
		if (pstrV == null) {
			return "";
		}
		return pstrV;
	}

	protected String BigInt2String(final BigInteger pbigI) {
		if (pbigI != null) {
			long lngT = pbigI.longValue();
			return String.valueOf(lngT);
		}
		return "";
	}

	protected BigInteger Int2BigInteger(final int pintVal) {
		return BigInteger.valueOf(pintVal);
	}

	protected String getQuoted(final String pstrVal) {
		return "\"" + pstrVal.trim() + "\"";
	}

}
