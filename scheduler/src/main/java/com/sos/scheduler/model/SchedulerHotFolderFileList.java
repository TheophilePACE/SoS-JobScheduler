/********************************************************* begin of preamble
**
** Copyright (C) 2003-2012 Software- und Organisations-Service GmbH. 
** All rights reserved.
**
** This file may be used under the terms of either the 
**
**   GNU General Public License version 2.0 (GPL)
**
**   as published by the Free Software Foundation
**   http://www.gnu.org/licenses/gpl-2.0.txt and appearing in the file
**   LICENSE.GPL included in the packaging of this file. 
**
** or the
**  
**   Agreement for Purchase and Licensing
**
**   as offered by Software- und Organisations-Service GmbH
**   in the respective terms of supply that ship with this file.
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
** IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
** THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
** PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
** BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
** CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
** SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
** INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
** CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
** ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
** POSSIBILITY OF SUCH DAMAGE.
********************************************************** end of preamble*/
package com.sos.scheduler.model;
import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.log4j.Logger;

import com.sos.VirtualFileSystem.Interfaces.ISOSVFSHandler;
import com.sos.VirtualFileSystem.Interfaces.ISOSVirtualFile;
import com.sos.scheduler.model.objects.JSObjBase;
import com.sos.scheduler.model.objects.JSObjJob;
import com.sos.scheduler.model.objects.JSObjJobChain;
import com.sos.scheduler.model.objects.JSObjLock;
import com.sos.scheduler.model.objects.JSObjOrder;
import com.sos.scheduler.model.objects.JSObjParams;
import com.sos.scheduler.model.objects.JSObjProcessClass;
import com.sos.scheduler.model.objects.JSObjSchedule;

/**
* \class SchedulerHotFolderFileList 
* 
* \brief SchedulerHotFolderFileList - 
* 
* \details
*
* \section SchedulerHotFolderFileList.java_intro_sec Introduction
*
* \section SchedulerHotFolderFileList.java_samples Some Samples
*
* \code
*   .... code goes here ...
* \endcode
*
* <p style="text-align:center">
* <br />---------------------------------------------------------------------------
* <br /> APL/Software GmbH - Berlin
* <br />##### generated by ClaviusXPress (http://www.sos-berlin.com) #########
* <br />---------------------------------------------------------------------------
* </p>
* \author oh
* @version $Id: SchedulerHotFolderFileList.java 20718 2013-07-18 18:16:10Z kb $
* \see reference
*
* Created on 28.02.2011 17:11:14
 */
/**
 * @author oh
 *
 */
public class SchedulerHotFolderFileList {

	private final String		conClassName	= "SchedulerHotFolderFileList";
	private static final Logger	logger			= Logger.getLogger(SchedulerHotFolderFileList.class);
	private List<JSObjBase>		fileList		= new ArrayList<JSObjBase>();
	private ISOSVirtualFile		hotFolderSrc	= null;

	public static enum HotFolderObject {
		folder, job, job_chain, order, lock, process_class, schedule, params;
	}

	public class GroupFolderAndSortByName implements Comparator<JSObjBase> {
		@Override
		public int compare(JSObjBase jsObjBase0, JSObjBase jsObjBase1) {
			int compareRet = 0;
			boolean jsObjBase0IsFolder = (jsObjBase0 instanceof SchedulerHotFolder);
			boolean jsObjBase1IsFolder = (jsObjBase1 instanceof SchedulerHotFolder);
			if (jsObjBase0IsFolder && !jsObjBase1IsFolder) {
				compareRet = -1;
			}
			else
				if (!jsObjBase0IsFolder && jsObjBase1IsFolder) {
					compareRet = 1;
				}
				else
					if (jsObjBase0.getHotFolderSrc() == null) {
						compareRet = 1;
					}
					else
						if (jsObjBase1.getHotFolderSrc() == null) {
							compareRet = -1;
						}
						else {
							String hotFolderSrcName0 = jsObjBase0.getHotFolderSrc().getName().toLowerCase();
							String hotFolderSrcName1 = jsObjBase1.getHotFolderSrc().getName().toLowerCase();
							compareRet = hotFolderSrcName0.compareTo(hotFolderSrcName1);
						}
			return compareRet;
		}
	}

	public SchedulerHotFolderFileList() {
		//
	}

	public List<JSObjBase> getFileList() {
		return fileList;
	}

	public List<JSObjBase> getSortedFileList() {
		Collections.sort(fileList, new GroupFolderAndSortByName());
		return fileList;
	}

	public List<JSObjBase> getSortedFileList(Comparator<JSObjBase> comp) {
		Collections.sort(fileList, comp);
		return fileList;
	}

	public void add(JSObjBase pObjHotFolderElement) {
		@SuppressWarnings("unused")
		final String conMethodName = conClassName + "::add";
		fileList.add(pObjHotFolderElement);
	} // public void add

	public void addAll(SchedulerHotFolderFileList pFileList) {
		@SuppressWarnings("unused")
		final String conMethodName = conClassName + "::addAll";
		fileList.addAll(pFileList.getFileList());
	} // public void add

	public List<SchedulerHotFolder> getFolderList() {
		@SuppressWarnings("unused")
		final String conMethodName = conClassName + "::getFolderList";
		List<SchedulerHotFolder> folders = new ArrayList<SchedulerHotFolder>();
		for (JSObjBase fileListItem : this.getFileList()) {
			if (fileListItem instanceof SchedulerHotFolder) {
				folders.add((SchedulerHotFolder) fileListItem);
			}
		}
		if (getHotFolderSrc() != null) {
			logger.debug(String.format("%1$s folders found in %2$s", folders.size(), getHotFolderSrc().getName()));
		}

		return folders;
	} // public List<SchedulerHotFolder> getFolderList

	public List<JSObjJob> getJobList() {
		@SuppressWarnings("unused")
		final String conMethodName = conClassName + "::getJobList";
		List<JSObjJob> jobs = new ArrayList<JSObjJob>();
		for (JSObjBase fileListItem : this.getFileList()) {
			if (fileListItem instanceof JSObjJob) {
				jobs.add((JSObjJob) fileListItem);
			}
		}
		if (getHotFolderSrc() != null) {
			logger.debug(String.format("%1$s jobs found in %2$s", jobs.size(), getHotFolderSrc().getName()));
		}
		return jobs;
	} // public List<JSObjJob> getJobList

	public List<JSObjJobChain> getJobChainList() {
		@SuppressWarnings("unused")
		final String conMethodName = conClassName + "::getJobChainList";
		List<JSObjJobChain> jobChains = new ArrayList<JSObjJobChain>();
		for (JSObjBase fileListItem : this.getFileList()) {
			if (fileListItem instanceof JSObjJobChain) {
				jobChains.add((JSObjJobChain) fileListItem);
			}
		}
		logger.debug(String.format("%1$s job chains found in %2$s", jobChains.size(), getHotFolderSrc().getName()));
		return jobChains;
	} // public List<JSObjJobChain> getJobChainList

	public List<JSObjOrder> getOrderList() {
		@SuppressWarnings("unused")
		final String conMethodName = conClassName + "::getOrderList";
		List<JSObjOrder> orders = new ArrayList<JSObjOrder>();
		for (JSObjBase fileListItem : this.getFileList()) {
			if (fileListItem instanceof JSObjOrder) {
				orders.add((JSObjOrder) fileListItem);
			}
		}
		logger.debug(String.format("%1$s orders found in %2$s", orders.size(), getHotFolderSrc().getName()));
		return orders;
	} // public List<JSObjOrder> getOrderList

	public List<ISOSVirtualFile> getOrderList(String filter) {
		Pattern pattern = Pattern.compile(filter);
		List<JSObjOrder> orders = getOrderList();
		List<ISOSVirtualFile> result = new ArrayList<ISOSVirtualFile>();
		for (JSObjOrder object : orders) { // das ist KEINE Auflistung von order Objekten!!
			File f = new File(object.getHotFolderSrc().getName());
			Matcher m = pattern.matcher(f.getName());
			if (m.matches()) {
				result.add(object.getHotFolderSrc());
			}
		}
		return result;
	}

	public List<JSObjProcessClass> getProcessClassList() {
		@SuppressWarnings("unused")
		final String conMethodName = conClassName + "::getProcessClassList";
		List<JSObjProcessClass> processClasses = new ArrayList<JSObjProcessClass>();
		for (JSObjBase fileListItem : this.getFileList()) {
			if (fileListItem instanceof JSObjProcessClass) {
				processClasses.add((JSObjProcessClass) fileListItem);
			}
		}
		logger.debug(String.format("%1$s process classes found in %2$s", processClasses.size(), getHotFolderSrc().getName()));
		return processClasses;
	} // public List<JSObjProcessClass> getProcessClassList

	public List<JSObjLock> getLockList() {
		@SuppressWarnings("unused")
		final String conMethodName = conClassName + "::getLockList";
		List<JSObjLock> locks = new ArrayList<JSObjLock>();
		for (JSObjBase fileListItem : this.getFileList()) {
			if (fileListItem instanceof JSObjLock) {
				locks.add((JSObjLock) fileListItem);
			}
		}
		logger.debug(String.format("%1$s locks found in %2$s", locks.size(), getHotFolderSrc().getName()));
		return locks;
	} // public List<JSObjLock> getLockList

	public List<JSObjSchedule> getScheduleList() {
		@SuppressWarnings("unused")
		final String conMethodName = conClassName + "::getScheduleList";
		List<JSObjSchedule> schedules = new ArrayList<JSObjSchedule>();
		for (JSObjBase fileListItem : this.getFileList()) {
			if (fileListItem instanceof JSObjSchedule) {
				schedules.add((JSObjSchedule) fileListItem);
			}
		}
		logger.debug(String.format("%1$s schedules found in %2$s", schedules.size(), getHotFolderSrc().getName()));
		return schedules;
	} // public List<JSObjSchedule> getScheduleList

	public List<JSObjParams> getParamsList() {
		@SuppressWarnings("unused")
		final String conMethodName = conClassName + "::getParamsList";
		List<JSObjParams> params = new ArrayList<JSObjParams>();
		for (JSObjBase fileListItem : this.getFileList()) {
			if (fileListItem instanceof JSObjParams) {
				params.add((JSObjParams) fileListItem);
			}
		}
		logger.debug(String.format("%1$s params found in %2$s", params.size(), getHotFolderSrc().getName()));
		return params;
	} // public List<JSObjParams> getParamsList

	/**
	 * 
	 * \brief getFileList
	 * 
	 * \details
	 *
	 * \return List<JSObjBase>
	 *
	 * @return
	 */
	public List<JSObjBase> getFileList(HotFolderObject... hotFolderObject) {
		@SuppressWarnings("unused")
		final String conMethodName = conClassName + "::getFileList";
		List<JSObjBase> filteredFileList = new ArrayList<JSObjBase>();
		// if(hotFolderObject.length == 0) {
		// filteredFileList = this.getFileList();
		// }
		// else {
		List<HotFolderObject> hotFolderObjectList = Arrays.asList(hotFolderObject);
		for (JSObjBase fileListItem : this.getFileList()) {
			if ((hotFolderObjectList.contains(HotFolderObject.folder) && fileListItem instanceof SchedulerHotFolder)
					|| (hotFolderObjectList.contains(HotFolderObject.job) && fileListItem instanceof JSObjJob)
					|| (hotFolderObjectList.contains(HotFolderObject.job_chain) && fileListItem instanceof JSObjJobChain)
					|| (hotFolderObjectList.contains(HotFolderObject.order) && fileListItem instanceof JSObjOrder)
					|| (hotFolderObjectList.contains(HotFolderObject.lock) && fileListItem instanceof JSObjLock)
					|| (hotFolderObjectList.contains(HotFolderObject.process_class) && fileListItem instanceof JSObjProcessClass)
					|| (hotFolderObjectList.contains(HotFolderObject.schedule) && fileListItem instanceof JSObjSchedule)
					|| (hotFolderObjectList.contains(HotFolderObject.params) && fileListItem instanceof JSObjParams)) {
				filteredFileList.add(fileListItem);
			}
		}
		// }
		logger.debug(String.format("%1$s objects found in %2$s", filteredFileList.size(), getHotFolderSrc().getName()));
		// Collections.sort(filteredFileList);
		return filteredFileList;
	} // public List<JSObjBase> getFileList

	public void setHotFolderSrc(ISOSVirtualFile hotFolderSrc) {
		this.hotFolderSrc = hotFolderSrc;
	}

	public ISOSVirtualFile getHotFolderSrc() {
		return hotFolderSrc;
	}

}
