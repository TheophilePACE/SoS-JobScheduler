/**
 * Copyright (C) 2014 BigLoupe http://bigloupe.github.io/SoS-JobScheduler/
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License
 */
/********************************************************* begin of preamble
**
** Copyright (C) 2003-2012 Software- und Organisations-Service GmbH. 
** All rights reserved.
**
** This file may be used under the terms of either the 
**
**   GNU General Public License version 2.0 (GPL)
**
**   as published by the Free Software Foundation
**   http://www.gnu.org/licenses/gpl-2.0.txt and appearing in the file
**   LICENSE.GPL included in the packaging of this file. 
**
** or the
**  
**   Agreement for Purchase and Licensing
**
**   as offered by Software- und Organisations-Service GmbH
**   in the respective terms of supply that ship with this file.
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
** IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
** THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
** PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
** BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
** CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
** SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
** INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
** CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
** ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
** POSSIBILITY OF SUCH DAMAGE.
********************************************************** end of preamble*/
package com.sos.dialog.classes;

import java.util.prefs.Preferences;

import org.apache.log4j.Logger;
import org.eclipse.swt.graphics.Point;
import org.eclipse.swt.widgets.Shell;
import org.eclipse.swt.widgets.Table;
import org.eclipse.swt.widgets.TableColumn;

/**
* \class WindowsSaver
*
* \brief WindowsSaver -
*
* \details
*
* \code
*   .... code goes here ...
* \endcode
*
* <p style="text-align:center">
* <br />---------------------------------------------------------------------------
* <br /> APL/Software GmbH - Berlin
* <br />##### generated by ClaviusXPress (http://www.sos-berlin.com) #########
* <br />---------------------------------------------------------------------------
* </p>
* \author Uwe Risse
* \version 08.11.2011
* \see reference
*
* Created on 08.11.2011 15:29:14
 */

public class WindowsSaver {

	private static final String	conWIN_LOCATE_Y	= "win:locateY:";
	private static final String	conWIN_LOCATE_X	= "win:locateX:";
	private static final String	conWIN_SIZE_Y	= "win:sizeY:";
	private static final String	conWIN_SIZE_X	= "win:sizeX:";

	@SuppressWarnings("unused")
	private final String			conClassName			= this.getClass().getSimpleName();

	@SuppressWarnings("unused")
	private static final String	conSVNVersion		= "$Id$";
	private final Logger	logger				= Logger.getLogger(this.getClass());

	private static final String	conPropertyWIDTH	= "width";

	private final Shell			shell;
	private final Preferences	prefs;
	private final Point			defaultSize;
	private final Point			defaultLocation;
	private final String		className;

	private String				strKey				= "";

	public void setKey(final String pstrKey) {
		strKey = pstrKey;
	}

	public WindowsSaver(final Class<?> c, final Shell s, final int x, final int y) {
		prefs = Preferences.userNodeForPackage(c);
		shell = s;
		className = c.getName();
		defaultSize = new Point(x, y);
		defaultLocation = new Point(100, 100);

	}

	private int getInt(final String s, final int def) {
		try {
			return Integer.parseInt(s);
		}
		catch (NumberFormatException e) {
			return def;
		}
	}

	public void restoreWindow() {
		restoreWindowSize();
		restoreWindowLocation();
		//		shell.setSize(getInt(prefs.get("win:sizeX:" + className, String.valueOf(defaultSize.x)), defaultSize.x),
		//				getInt(prefs.get("win:sizeY:" + className, String.valueOf(defaultSize.y)), defaultSize.y));
		//		shell.setLocation(getInt(prefs.get("win:locateX:" + className, String.valueOf(defaultLocation.x)), defaultLocation.x),
		//				getInt(prefs.get("win:locateY:" + className, String.valueOf(defaultLocation.y)), defaultLocation.y));

	}

	public void restoreWindowLocation() {
		if (shell != null) {
			int x = getInt(prefs.get(conWIN_LOCATE_X + className, String.valueOf(defaultLocation.x)), defaultLocation.x);
			int y = getInt(prefs.get(conWIN_LOCATE_Y + className, String.valueOf(defaultLocation.y)), defaultLocation.y);
			logger.debug ("restoreWindowLocation: x = " + x + ", y = " + y);
			shell.setLocation(x, y);
		}
		else {
			logger.debug("shell is null");
		}
	}

	public Point getWindowSize() {
		int x = getInt(prefs.get(conWIN_SIZE_X + className, String.valueOf(defaultSize.x)), defaultSize.x);
		int y = getInt(prefs.get(conWIN_SIZE_Y + className, String.valueOf(defaultSize.y)), defaultSize.y);
		logger.debug ("getWindowSize: x = " + x + ", y = " + y);
		return new Point(x, y);
	}

	public void restoreWindowSize() {
		shell.setSize(getWindowSize());
		logger.debug(className + ": Windws size and position restored");
	}

	public void saveWindowPosAndSize() {
		saveWindow();
	}

	public void saveWindow() {
		if (shell != null) {
			int x = shell.getSize().x;
			int y = shell.getSize().y;
			logger.debug ("saveWindowSize: x = " + x + ", y = " + y);

			prefs.put(conWIN_SIZE_X + className, String.valueOf(x));
			prefs.put(conWIN_SIZE_Y + className, String.valueOf(y));

			x = shell.getLocation().x;
			y = shell.getLocation().y;
			logger.debug ("saveWindowLocation: x = " + x + ", y = " + y);

			prefs.put(conWIN_LOCATE_X + className, String.valueOf(shell.getLocation().x));
			prefs.put(conWIN_LOCATE_Y + className, String.valueOf(shell.getLocation().y));
			logger.debug(className + ": Windows size and position saved.");
		}
		else {
			logger.debug("shell is null");
		}
	}

	private String getPropertyKey() {
		return "properties/" + strKey;
	}

	public void saveProperty(final String pstrPropName, final String pstrPropValue) {
		prefs.node(getPropertyKey()).put(pstrPropName, pstrPropValue);
		logger.debug(String.format("saveProperty %1$s = %2$s", pstrPropName, pstrPropValue));
	}

	public String getProperty(final String pstrPropName) {
		String strR = prefs.node(getPropertyKey()).get(pstrPropName, "");
		logger.debug(String.format("getProperty %1$s = %2$s", pstrPropName, strR));
		return strR;
	}

	public void saveTableColumn(final String tableName, final TableColumn t) {
		String strCaption = (String) t.getData("caption");
		if (strCaption == null) {
			strCaption = t.getText();
		}
		String name = tableName + "/col/" + "_" + strCaption;
		logger.debug("save column: " + name);
		prefs.node(name).put(conPropertyWIDTH, String.valueOf(t.getWidth()));
	}

	public void TableColumnOrderRestore(final Table pobjTable) {

		String name = pobjTable.getData("caption") + "/colorder/default";
		String strNoOfColumn = prefs.node(name).get("NoOfColumns", "");
		if (strNoOfColumn.length() > 0) {
			int intNoOfColumn = new Integer(strNoOfColumn);
			if (intNoOfColumn == pobjTable.getColumnCount()) {
				int[] i = new int[intNoOfColumn];
				String strColOrder = prefs.node(name).get("columnorder", "");
				if (strColOrder.length() > 0) {
					int iCol = 0;
					for (String strIndex : strColOrder.split(";")) {
						if (strIndex.length() > 0) {
							i[iCol++] = new Integer(strIndex);
						}
					}
					pobjTable.setColumnOrder(i);
				}
			}
		}
	}

	public void TableColumnOrderSave(final Table pobjTable) {
		String strOrder = "";
		int intSize = pobjTable.getColumnOrder().length;
		for (int i : pobjTable.getColumnOrder()) {
			strOrder += i + ";";
		}
		String name = pobjTable.getData("caption") + "/colorder/default";
		logger.debug("save column order: " + name + ", " + strOrder);
		prefs.node(name).put("columnorder", strOrder);
		prefs.node(name).put("NoOfColumns", intSize + "");

		//	        for (int i = 0; i < order.length / 2; i++) {
		//	          int temp = order[i];
		//	          order[i] = order[order.length - i - 1];
		//	          order[order.length - i - 1] = temp;
		//	        }
		//	        table.setColumnOrder(order);
	}

	public void restoreTableColumn(final String tableName, final TableColumn t, final int def) {
		String strCaption = (String) t.getData("caption");
		if (strCaption == null) {
			strCaption = t.getText();
		}
		String name = tableName + "/col/" + "_" + strCaption;
		try {
			String strVal = prefs.node(name).get(conPropertyWIDTH, String.valueOf(def));
			logger.debug(String.format("restore column '%1$s' with size '%2$s': ", name, strVal));
			t.setWidth(this.getInt(strVal, def));
		}
		catch (Exception e) {
			t.setWidth(def);
		}
	}
}
