/**
 * Copyright (C) 2014 BigLoupe http://bigloupe.github.io/SoS-JobScheduler/
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License
 */
/********************************************************* begin of preamble
**
** Copyright (C) 2003-2012 Software- und Organisations-Service GmbH. 
** All rights reserved.
**
** This file may be used under the terms of either the 
**
**   GNU General Public License version 2.0 (GPL)
**
**   as published by the Free Software Foundation
**   http://www.gnu.org/licenses/gpl-2.0.txt and appearing in the file
**   LICENSE.GPL included in the packaging of this file. 
**
** or the
**  
**   Agreement for Purchase and Licensing
**
**   as offered by Software- und Organisations-Service GmbH
**   in the respective terms of supply that ship with this file.
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
** IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
** THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
** PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
** BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
** CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
** SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
** INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
** CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
** ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
** POSSIBILITY OF SUCH DAMAGE.
********************************************************** end of preamble*/
package com.sos.JSHelper.Options;
/**
* \class JSDataElement
*
* \brief JSDataElement - Basisklasse f�r die Datenelement-Klassen des Dataswitch
*
* \details
* Basisklasse (SuperKlasse) f�r die Datenelement-Klassen des Dataswitch
*
* \section JSOptionClass_intro_sec Introduction
*
* \section JSOptionClass_samples Some Samples
*
* \code
*   .... code goes here ...
* \endcode
*
* <p style="text-align:center">
* <br />---------------------------------------------------------------------------
* <br /> APL/Software GmbH - Berlin
* <br />##### generated by ClaviusXPress (http://www.sos-berlin.com) #########
* <br />Sonntag, 7. Dezember 2008, eqbfd (eqbfd)
* <br />---------------------------------------------------------------------------
* </p>
* \author eqbfd
* @version $Id: SOSOptionElement.java 20722 2013-07-18 18:19:03Z kb $0.9
*
 */
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Stack;
import java.util.Vector;

import org.apache.log4j.Logger;

import com.sos.JSHelper.Basics.JSToolBox;
import com.sos.JSHelper.Exceptions.JSExceptionMandatoryOptionMissing;
import com.sos.JSHelper.io.Files.JSXMLFile;
import com.sos.i18n.annotation.I18NResourceBundle;

@I18NResourceBundle(baseName = "com_sos_JSHelper_Messages", defaultLocale = "en")
public class SOSOptionElement extends JSToolBox implements Serializable, ISOSOptions {
	/**
	 *
	 */
	private static final long					serialVersionUID			= -7652466722187678671L;
	public final String							ControlType					= "text";

	private static final String					conClassName				= "JSOptionElement";
	protected static Logger						logger						= Logger.getLogger(SOSOptionElement.class);
	public static boolean						gflgProcessHashMap			= true;
	public static boolean						gflgCreateShortXML			= false;									// item-based with name and value
																														// attribute
	private Stack<String>						objValueStack				= null;

	private ArrayList<IValueChangedListener>	lstValueChangedListeners	= null;

	protected String							strKey						= "";
	protected String							strValue					= "";
	private String								strDefaultValue				= "";
	private boolean								flgIsDirty					= false;
	protected boolean							flgValue					= false;
	protected JSOptionsClass					objOptions					= null;
	protected Vector<String>					objAliase					= new Vector<String>();
	protected static final int					isOptionTypeString			= 0;
	protected static final int					isOptionTypeBoolean			= 1;
	protected static final int					isOptionTypeFileName		= 2;
	protected static final int					isOptionTypeInteger			= 3;
	public static final int						isOptionTypeOptions			= 4;
	protected static final int					isOptionTypeFolder			= 5;
	protected int								intOptionType				= 0;										// 0 = String, 1
																														// = boolean, 2
																														// = File .....
	private boolean								flgIsMandatory				= false;
	private String								strDescription				= "";
	private int									intSize						= 0;										// Size in Bytes
	private String								strTitle					= "";
	private String								strColumnHeader				= "";
	private String								strXMLTagName				= "";
	private String								strFormatString				= "";										// geh�rt in
																														// Integer,
																														// Double, etc
	protected JSOptionsClass					objParentClass				= null;
	protected static final String				conNullButMandatory			= "JSO-D-0011";							// "Setting %1$s (%2$s) is mandatory, must be not null.%n";
	protected static final String				conChangedMsg				= "JSO-D-0010";							// "changed from '%1$s' to '%2$s'.";
	protected boolean							flgHideValue				= false;
	protected boolean							flgHideOption				= false;
	/**
	 * \todo Werte(bereichs)pr�fung mit dem regul�ren Ausdruck einbauen
	 */
	@SuppressWarnings("unused")
	private final String						strRegExpr4Check			= "";
	protected boolean							isCData						= false;

	public void addValueChangedListener(final IValueChangedListener pobjValueChangedListener) {

		if (lstValueChangedListeners == null) {
			lstValueChangedListeners = new ArrayList<IValueChangedListener>();
		}

		lstValueChangedListeners.add(pobjValueChangedListener);
	}

	private void raiseValueChangedListener() {
		if (lstValueChangedListeners != null) {
			for (IValueChangedListener objValueChangedListener : lstValueChangedListeners) {
				objValueChangedListener.ValueHasChanged(strValue);
			}
		}
	}

	/**
	 *
	 * \brief toString
	 *
	 * \details
	 *
	 * \return
	 *
	 * @return
	 */
	@Override
	public String toString() {
		String strR = "";
		if (flgHideOption == false) {
			String strV = strValue;
			if (flgHideValue == true) {
				strV = "*****";
			}
			strR = strKey + " (" + strDescription + "): " + strV;
		}
		return strR;
	}

	public String DirtyToString() {
		String strR = "";
		if (flgHideOption == false && this.isDirty()) {
			String strV = strValue;
			if (flgHideValue == true) {
				strV = "*****";
			}
			strR = this.getShortKey() + " : " + strV;
		}
		return strR;
	}

	public void changeDefaults(final String pstrValue, final String pstrDefaultValue) {

		@SuppressWarnings("unused")
		final String conMethodName = conClassName + "::changeDefaults";

		strDefaultValue = getValue(pstrDefaultValue);
		this.Value(getValue(pstrValue));
		flgIsDirty = false;

	} // public void changeDefaults

	public void changeDefaults(final int pintValue, final int pintDefaultValue) {

		@SuppressWarnings("unused")
		final String conMethodName = conClassName + "::changeDefaults";

		strDefaultValue = String.valueOf(pintDefaultValue);
		this.Value(String.valueOf(pintValue));
		flgIsDirty = false;

	} // public void changeDefaults

	public boolean isDefault() {

		@SuppressWarnings("unused")
		final String conMethodName = conClassName + "::isDefault";

		return strValue.equalsIgnoreCase(strDefaultValue);

	} // private boolean  isDefault

	public SOSOptionElement(final JSOptionsClass pobjParent, final String pstrKey, final String pstrDescription, final String pstrValue,
			final String pstrDefaultValue, final boolean pflgIsMandatory) {
		try {
			this.setMessageResource("com_sos_JSHelper_Messages");
			objParentClass = pobjParent;
			if (objParentClass != null) {
				this.registerMessageListener(objParentClass.Listener());
			}
			strKey = pstrKey;
			strDefaultValue = getValue(pstrDefaultValue);
			this.Description(pstrDescription);
			strTitle = pstrDescription;
			flgIsMandatory = pflgIsMandatory;
			strXMLTagName = pstrKey;
			strColumnHeader = pstrKey;

			this.Value(getValue(pstrValue));
			flgIsDirty = false;
		} // try
		catch (final Exception objException) {
			objException.printStackTrace();
		}
		finally {
			//
		} // finally
	}

	private String getValue(final String pstrValue) {
		String strRet = null;
		if (pstrValue == null) {
			strRet = null;
		}
		else {
			if (pstrValue.toLowerCase().startsWith("env:") == true) {
				String strEnvVarName = pstrValue.substring(4);
				String strEnvVarValue = EnvironmentVariable(strEnvVarName);
				if (isEmpty(strEnvVarValue) == true) {
					strRet = System.getProperty(strEnvVarName);
					if (isEmpty(strRet) == true) {
						strRet = strDefaultValue;
					}
				}
				else {
					strRet = strEnvVarValue;
				}
			}
			else {
				if (pstrValue.contains("${")) {
					int iFrom = pstrValue.indexOf("${");
					int iTo = pstrValue.indexOf("}");
					if (iTo != -1) {
						String strEnvVarName = pstrValue.substring(iFrom + 2, iTo);
						String strEnvVarValue = EnvironmentVariable(strEnvVarName);
						strRet = "";
						if (iFrom > 0) {
							strRet = pstrValue.substring(0, iFrom);
						}
						strRet += strEnvVarValue;
						strRet += pstrValue.substring(iTo + 1);
					}
				}
				else {
					strRet = pstrValue;
				}
			}
		}
		return strRet;
	}

	public String getShortXMLTagName() {
		String strT = this.XMLTagName();
		int i = strT.indexOf(".");
		if (i > 0) {
			strT = strT.substring(i + 1);
		}
		return strT;
	}

	public String getShortKey() {
		String strT = strKey;
		int i = strT.indexOf(".");
		if (i > 0) {
			strT = strT.substring(i + 1);
		}
		return strT;
	}

	public void setDirty() {
		flgIsDirty = true;
	}

	public void setNotDirty() {
		flgIsDirty = false;
	}

	public boolean isDirty() {
		@SuppressWarnings("unused")
		final String conMethodName = conClassName + "::isDirty";
		return flgIsDirty;
	} // private boolean isDirty

	public boolean isNotDirty() {
		@SuppressWarnings("unused")
		final String conMethodName = conClassName + "::isDirty";
		return !flgIsDirty;
	} // private boolean isDirty

	/**
	 *
	 * \brief ColumnHeader
	 *
	 * \details
	 *
	 * \return JSOptionClass
	 *
	 * @param pstrColumnHeader
	 * @return
	 */
	public SOSOptionElement ColumnHeader(final String pstrColumnHeader) {
		if (pstrColumnHeader != null) {
			strColumnHeader = pstrColumnHeader;
		}
		return this;
	}

	/**
	 *
	 * \brief ColumnHeader
	 *
	 * \details
	 *
	 * \return String
	 *
	 * @return
	 */
	public String ColumnHeader() {
		if (strColumnHeader == null) {
			strColumnHeader = "";
		}
		return strColumnHeader;
	}

	/**
	 * \brief Title - Titel des Datenelements festlegen
	 *
	 * \details
	 *
	 * @param pstrTitle
	 * @return
	 */
	public SOSOptionElement Title(final String pstrTitle) {
		if (pstrTitle != null) {
			strTitle = pstrTitle;
		}
		return this;
	}

	/**
	 * \brief Title - Titel des Datenelements liefern
	 *
	 * \details
	 *
	 * @param pstrTitle
	 * @return
	 */
	public String Title() {
		if (strTitle == null) {
			strTitle = "";
		}
		return strTitle;
	}

	/**
	 *
	 * \brief DefaultValue
	 *
	 * \details
	 *
	 * \return String
	 *
	 * @return
	 */
	public String DefaultValue() {
		@SuppressWarnings("unused")
		final String conMethodName = SOSOptionElement.conClassName + "::DefaultValue";
		return strDefaultValue;
	} // public String DefaultValue

	public void DefaultValue(final String pstrValue) {

		@SuppressWarnings("unused")
		final String conMethodName = conClassName + "::setDefaultValue";

		strDefaultValue = pstrValue;

		//	return void;
	} // private void setDefaultValue

	public String setPrefix(final String strPrefix) {
		@SuppressWarnings("unused")
		final String conMethodName = conClassName + "::setPrefix";
		String strT = strKey;
		int i = strT.indexOf(".");
		if (i > 0) {
			strT = strT.replaceFirst("\\.", "." + strPrefix);
		}
		else {
			strT = strPrefix + strT;
		}
		strKey = strT;
		return strT;
	}

	/**
	 *
	 * \brief getKey
	 *
	 * \details
	 *
	 * \return String
	 */
	public String getKey() {
		@SuppressWarnings("unused")
		final String conMethodName = SOSOptionElement.conClassName + "::getKey";
		return strKey;
	} // private String getKey

	/**
	 * \brief Value - Wert des Datenelements festlegen
	 *
	 * \details
	 *
	 * @param pstrValue
	 * @return
	 * @throws Exception
	 */
	@Override
	public void Value(final String pstrValue) {
		if (flgIsMandatory) {
			if (pstrValue == null) {
				if (gflgProcessHashMap == false) {
					// this.SignalError(Messages.getMsg(SOSOptionElement.conNullButMandatory, this.strTitle, this.strKey));
					// logger.error(Messages.getMsg(SOSOptionElement.conNullButMandatory, this.strTitle, this.strKey));
				}
				else {
					return; // to avoid to overwrite a previous assigned value
				}
			}
		}
		if (pstrValue != null) {
			/**
			 * \todo �ber den regexp pr�fen, ob die Werte syntaktisch korrekt sind
			 */
			if (objParentClass != null) {
				final String strTemp = objParentClass.SubstituteVariables(pstrValue);
				// if (strTemp != null && strValue != null && strTemp.trim().equals(strValue.trim()) == false) {
				// logger.debug(Messages.getMsg(this.conChangedMsg, this.strValue, strTemp, this.strTitle));
				// }
				// this.SignalDebug(String.format(this.conChangedMsg, this.strValue, strTemp, this.strTitle));
			}
			strValue = pstrValue;
		}
		else {
			strValue = "";
		}
		// logger.debug(conClassName + ", key = " + strKey + ", value = " + strValue);
		flgIsDirty = true;
		raiseValueChangedListener();
	}

	public void setNull() {
		strValue = null;
	}

	/**
	 * \brief Value - Wert der Option liefern
	 *
	 * \details
	 *
	 * @param pstrValue
	 * @return
	 */
	public String Value() throws RuntimeException {
		if (strValue == null) {
			strValue = "";
		}
		return strValue;
	}

	/**
	 * \brief Description - Beschreibung des Datenelements festlegen
	 *
	 * \details
	 *
	 * @param pstrDescription
	 * @return
	 */
	public SOSOptionElement Description(final String pstrDescription) {
		if (pstrDescription != null) {
			strDescription = pstrDescription;
		}
		return this;
	}

	/**
	 * \brief Description - Beschreibung des Datenelements liefern
	 *
	 * \details
	 *
	 * @param pstrDescription
	 * @return String
	 */
	public String Description() {
		if (strDescription == null) {
			strDescription = "";
		}
		return strDescription;
	}

	/**
	 * \brief Size - Gr��e des Datenelements festlegen
	 *
	 * \details
	 *
	 * @param pintSize
	 * @return
	 */
	public SOSOptionElement Size(final int pintSize) {
		intSize = pintSize;
		return this;
	}

	public SOSOptionElement Size(final Integer pintSize) {
		intSize = pintSize;
		return this;
	}

	/**
	 * \brief Size - Gr��e des Datenelements liefern
	 *
	 * \details
	 *
	 * @param pintSize
	 * @return String
	 */
	public int Size() {
		return intSize;
	}

	public Integer ISize() {
		return new Integer(intSize);
	}

	/**
	 * \brief XMLTagName - XML-TagName des Datenelements festlegen
	 *
	 * \details
	 *
	 * @param pstrXMLTagName
	 * @return
	 */
	public SOSOptionElement XMLTagName(final String pstrXMLTagName) {
		if (pstrXMLTagName != null) {
			strXMLTagName = pstrXMLTagName;
		}
		return this;
	}

	/**
	 * \brief XMLTagName - XML-TagName der Option liefern
	 *
	 * \details
	 *
	 * @param pstrXMLTagName
	 * @return String
	 */
	public String XMLTagName() {
		if (strXMLTagName == null) {
			strXMLTagName = "";
		}
		return strXMLTagName;
	}

	public String toXml(final String pstrTagName) throws Exception {
		String strRet = " ";
		String strT = this.XMLTagName();
		try {
			this.XMLTagName(pstrTagName);
			strRet = toXml();
		}
		catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		finally {
			this.XMLTagName(strT);
		}
		return strRet;
	}

	public String createShortXml() {
		String strT = "<item ";
		strT += " name='" + this.getShortXMLTagName() + "'";
		// if (this.isDirty() == true) {
		strT += " value='";
		strT += this.Value().trim();
		strT += "' ";
		// }
		strT += "/>";
		return strT;
	}

	/**
	 * \brief toXml - XML-Tag mit dem Wert der Option liefern
	 *
	 * \details
	 *
	 * @return String - den Wert der Option im XML-Tag
	 * @throws Exception
	 */
	public String toXml() throws Exception {
		String strT = "";
		if (gflgCreateShortXML == true) {
			strT = createShortXml();
		}
		else {
			strT = "<" + this.XMLTagName();
			strT += " mandatory=" + QuotedValue(boolean2String(flgIsMandatory));
			if (isNotEmpty(strDefaultValue)) {
				strT += " default=" + QuotedValue(strDefaultValue);
			}
			if (isNotEmpty(strTitle)) {
				strT += " title=" + QuotedValue(strTitle);
			}
			strT += ">";
			if (this.Value().length() > 0) {
				if (isCData) {
					strT += "<![CDATA[" + this.FormattedValue() + "]]>";
				}
				else {
					strT += this.Value();
				}
			}
			strT += "</" + this.XMLTagName() + ">";
		}
		return strT;
	}

	/**
	 *
	 * \brief toXml
	 *
	 * \details
	 *
	 * \return void
	 *
	 * @param pobjXMLFile
	 * @throws Exception
	 */
	public void toXml(final JSXMLFile pobjXMLFile) throws Exception {
		pobjXMLFile.WriteLine(this.toXml());
	}

	/**
	 *
	 * \brief FormatString
	 *
	 * \details
	 *
	 * \return void
	 *
	 * @param pstrFormatString
	 */
	public void FormatString(final String pstrFormatString) {
		if (pstrFormatString == null) {
			strFormatString = "";
		}
		else {
			strFormatString = pstrFormatString;
		}
	}

	/**
	 *
	 * \brief FormatString - liefert den f�r die Option definierten FormatString
	 *
	 * \details
	 *
	 * \return String
	 *
	 * @return
	 */
	public String FormatString() {
		if (strFormatString == null) {
			strFormatString = "";
		}
		return strFormatString;
	}

	protected void doInit() {
		//
	}

	/**
	 *
	 * \brief FormattedValue - Liefert den Wert der Option formatiert
	 *
	 * \details
	 * das Format (die Edit-Maske) wird �ber die Eigenschaft FormatString
	 * definiert.
	 *
	 * Wenn kein Format-String definiert ist, so wird der Wert als String
	 * zur�ckgegeben.
	 *
	 * \return String
	 *
	 * @return
	 * @throws Exception
	 */
	public String FormattedValue() throws Exception {
		// nur �berschreibbar
		return this.Value();
	}

	/**
	 *
	 * \brief IsEmpty
	 *
	 * \details
	 * Ist Value-String leer, dann liefert die Methode true
	 *
	 * \return boolean
	 *
	 * @return
	 * @throws Exception
	 */
	public boolean IsEmpty() throws RuntimeException {
		if (strValue != null) {
			return strValue.trim().length() == 0;
		}
		else {
			return true;
		}
	}

	public boolean IsNull() {
		return strValue == null;
	}

	public boolean IsNotEmpty() throws RuntimeException {
		return !this.IsEmpty();
	}

	/**
	 *
	 * \brief MapValue - Wert der Option aus der HashTable �bernehmen
	 *
	 * \details
	 * Mit dieser Methode wird aus der HashTable f�r den f�r diese Option
	 * definierten Key der eingestellte Wert �bernommen.
	 *
	 * Ist der gesuchte Key, und damit der Wert, nicht in der HashTable,
	 * so wird der Default-Wert zugewiesen.
	 * \return void
	 *
	 * @throws Exception
	 */
	public void MapValue() {
		@SuppressWarnings("unused")
		final String conMethodName = SOSOptionElement.conClassName + "::MapValue";
		/**
		 * \todo Wenn abgeleitete Klassen in der Value()-Methode pr�fungen auf g�ltige Werte haben
		 * und ein "leerer" String ein ung�ltiger Wert ist, dann wird dieser ung�ltige Wert nicht erkannt.
		 */
		if (this.isEmpty(strKey) == false) {
			String strV = objParentClass.getItem(strKey, null);
			if (strV == null) {
				for (String strAlias : objAliase) {
					strV = objParentClass.getItem(strAlias, null);
					if (strV != null) {
						break;
					}
				}
			}
			/*
			 * // TODO check for global prefix
			 */
			if (strV == null) {
				strV = strDefaultValue;
			}
			else { // warum auf default setzen wenn er nicht in der hashmap ist? Dann unver�ndert lassen

				this.Value(strV);
			}
			// - <remark who='EQALS' when='Dienstag, 6. Oktober 2009' id='PublishSQLStatement' >
			/**
			 * TODO Werte-Trenner als Eigenschaft des JSOptionElements statt konstant
			 * \todo Werte-Trenner als Eigenschaft des JSOptionElements statt konstant
			 */
			// - <newcode>
			if (intOptionType == isOptionTypeOptions) {
				this.Value(objParentClass.getIndexedItem(strKey, this.Description(), ";"));
			}
			// - </newcode>
			// - </remark> <!-- id=<PublishSQLStatement> -->
		}
	} // public void MapValue

	/**
	* \brief CheckMandatory - pr�ft ob eine Option tats�chlich gef�llt ist
	*
	* \details
	*
	* @throws Exception - wird ausgel�st, wenn eine mandatory-Option keinen Wert hat
	*/
	public void CheckMandatory() {
		try {
			if (flgIsMandatory) {
				if (this.isEmpty(strValue)) {
					//					this.SignalError(Messages.getMsg("%1$s (%2$s) %3$s", this.strDescription, this.strKey, this.conNullButMandatory));
					this.SignalError(Messages.getMsg(SOSOptionElement.conNullButMandatory, strDescription, strKey));
				}
			}
		}
		catch (final Exception e) {
			throw new JSExceptionMandatoryOptionMissing(e.toString());
		}
	} // public void CheckMandatory ()

	/**
	 *
	 * \brief toOut
	 *
	 * \details
	 *
	 * \return String
	 *
	 * @return
	 * @throws Exception
	 */
	public String toOut() throws Exception {
		@SuppressWarnings("unused")
		final String conMethodName = SOSOptionElement.conClassName + "::toOut";
		String strT = "";
		strT = String.format("%1$s %2$s: %3$s \n", strTitle, strDescription, this.Value());
		return strT;
	} // public String toOut}

	public int OptionType() {
		return intOptionType;
	}

	/**
	 *
	 * \brief OptionType
	 *
	 * \details
	 *
	 * \return void
	 *
	 * @param pintOptionType
	 */
	public void OptionType(final int pintOptionType) {
		intOptionType = pintOptionType;
	}

	/**
	 *
	 * \brief isMandatory
	 *
	 * \details
	 *
	 * \return void
	 *
	 * @param pflgIsMandatory
	 */
	public void isMandatory(final boolean pflgIsMandatory) {
		@SuppressWarnings("unused")
		final String conMethodName = conClassName + "::isMandatory";
		flgIsMandatory = pflgIsMandatory;
	} // private void isMandatory

	public boolean isMandatory() {
		@SuppressWarnings("unused")
		final String conMethodName = conClassName + "::isMandatory";
		return flgIsMandatory;
	} // private boolean isMandatory

	public SOSOptionElement SetAlias(final String pstrAliasKey) {
		@SuppressWarnings("unused")
		final String conMethodName = conClassName + "::setAlias";
		objAliase.add(pstrAliasKey);
		return this;
	} // private void setAlias

	public SOSOptionElement SetAlias(final String... pstrAliasKey) {
		@SuppressWarnings("unused")
		final String conMethodName = conClassName + "::setAlias";
		for (String string : pstrAliasKey) {
			objAliase.add(string);
		}
		return this;
	} // private void setAlias

	/**
	 *
	 * \brief String to Boolean
	 *
	 * \details
	 *
	 * \return boolean
	 *
	 * @param pstrS
	 */
	public boolean String2Bool() {
		boolean flgT = false;
		String pstrVal = strValue;
		if (isNotEmpty(pstrVal)) {
			if (pstrVal.equals("1") || pstrVal.equalsIgnoreCase("y") || pstrVal.equalsIgnoreCase("yes") || pstrVal.equalsIgnoreCase("j")
					|| pstrVal.equalsIgnoreCase("on") || pstrVal.equalsIgnoreCase("true") || pstrVal.equalsIgnoreCase("wahr")) {
				flgT = true;
			}
		}
		return flgT;
	}

	/**
	 *
	 * \brief QuotedValue
	 *
	 * \details
	 *
	 * \return String
	 *
	 * @return
	 */
	public String QuotedValue() {
		@SuppressWarnings("unused")
		final String conMethodName = conClassName + "::QuotedValue";
		return this.QuotedValue(strValue);
	} // private String QuotedValue

	/**
	 *
	 * \brief QuotedValue
	 *
	 * \details
	 *
	 * \return String
	 *
	 * @param pstrValue
	 * @return
	 */
	public String QuotedValue(final String pstrValue) {
		@SuppressWarnings("unused")
		final String conMethodName = conClassName + "::QuotedValue";
		String strRet = "\"" + pstrValue.replaceAll("\"", "\"\"") + "\"";
		return strRet;
	} // private String QuotedValue

	public String OptionalQuotedValue() {
		String strR = strValue;
		if (strR.indexOf(" ") > -1) {
			strR = QuotedValue(strR);
		}
		return strR;
	}

	public String toCommandLine() {
		String strRet = "";
		if (IsNotEmpty() && isDirty() == true && strValue.equalsIgnoreCase(strDefaultValue) == false) {
			strRet = "-" + this.getShortKey() + "=" + OptionalQuotedValue() + " ";
		}
		return strRet;
	}

	/**
	 *
	 * \brief equalsIgnoreCase
	 *
	 * \details
	 *
	 * \return boolean
	 *
	 * @param strCompare
	 * @return
	 */
	public boolean equalsIgnoreCase(final String strCompare) {
		if (strValue == null) {
			return false;
		}
		return strValue.equalsIgnoreCase(strCompare);
	}

	/**
	 * \brief gethideValue
	 *
	 * \details
	 * getter
	 *
	 * @return the hideValue
	 */
	public boolean isHideValue() {
		return flgHideValue;
	}

	/**
	 * \brief sethideValue -
	 *
	 * \details
	 * setter
	 *
	 * @param hideValue the value for hideValue to set
	 */
	public void setHideValue(final boolean hideValue) {
		flgHideValue = hideValue;
	}

	/**
	 * \brief gethideOption
	 *
	 * \details
	 * getter
	 *
	 * @return the hideOption
	 */
	public boolean isHideOption() {
		return flgHideOption;
	}

	/**
	 * \brief sethideOption -
	 *
	 * \details
	 * setter
	 *
	 * @param hideOption the value for hideOption to set
	 */
	public void setHideOption(final boolean hideOption) {
		flgHideOption = hideOption;
	}

	public String StripQuotes(final String pstrS) {
		String strR = pstrS;
		if (pstrS.substring(0, 1).equals("\"") && pstrS.substring(pstrS.length() - 1).equals("\"")) {
			strR = pstrS.substring(1, pstrS.length() - 1);
		}

		return strR;
	}

	public byte[] getBytes() {
		return strValue.getBytes();
	}

	public Stack<String> getStack() {
		if (objValueStack == null) {
			objValueStack = new Stack<String>();
		}
		return objValueStack;
	}

	public void push() {
		getStack().push(strValue);
	}

	public void pop() {
		String strT = getStack().pop();
		this.Value(strT);
	}
}
