/**
 * Copyright (C) 2014 BigLoupe http://bigloupe.github.io/SoS-JobScheduler/
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License
 */
/********************************************************* begin of preamble
**
** Copyright (C) 2003-2012 Software- und Organisations-Service GmbH. 
** All rights reserved.
**
** This file may be used under the terms of either the 
**
**   GNU General Public License version 2.0 (GPL)
**
**   as published by the Free Software Foundation
**   http://www.gnu.org/licenses/gpl-2.0.txt and appearing in the file
**   LICENSE.GPL included in the packaging of this file. 
**
** or the
**  
**   Agreement for Purchase and Licensing
**
**   as offered by Software- und Organisations-Service GmbH
**   in the respective terms of supply that ship with this file.
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
** IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
** THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
** PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
** BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
** CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
** SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
** INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
** CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
** ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
** POSSIBILITY OF SUCH DAMAGE.
********************************************************** end of preamble*/
package com.sos.JSHelper.io.Files;
import java.io.IOException;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

import org.apache.log4j.Logger;

import com.sos.JSHelper.Annotations.JSOptionClass;
import com.sos.JSHelper.Exceptions.JobSchedulerException;

/**
* \class JSIniFile 
* 
* \brief JSIniFile - 
* 
* \details
*
*
* \code
*   .... code goes here ...
* \endcode
*
* <p style="text-align:center">
* <br />---------------------------------------------------------------------------
* <br /> APL/Software GmbH - Berlin
* <br />##### generated by ClaviusXPress (http://www.sos-berlin.com) #########
* <br />---------------------------------------------------------------------------
* </p>
* \author KB
* \version $Id$
* \see reference
*
* Created on 26.08.2011 20:46:21
 */

/**
 * @author KB
 *
 */
@JSOptionClass(name = "JSOptionsClass", description = "JSOptionsClass")
public class JSIniFile extends JSTextFile {

	private static final long						serialVersionUID			= -1960627326921434568L;
	@SuppressWarnings("unused")
	private final String							conClassName				= "JSIniFile";
	private static final String						conSVNVersion				= "$Id$";
	private static final Logger						logger						= Logger.getLogger(JSIniFile.class);

	private final Map<String, SOSProfileSection>	mapSections					= new HashMap<String, SOSProfileSection>();
	// private final Map <String, SOSProfileSection> mapSections = new LinkedList <String, SOSProfileSection>();

	private String									strSectionName				= null;
	private boolean									flgIgnoreDuplicateSections	= true;
	private boolean									flgIsDirty					= false;
	private SOSProfileSection						objCurrentSection			= null;
	private JSTextFile								objSaveFile					= null;

	/**
	 * \brief JSIniFile
	 *
	 * \details
	 *
	 * @param pstrFileName
	 */
	public JSIniFile(String pstrFileName) {
		super(pstrFileName);
		if (fleFile.exists()) {
			getIniFile();
		}
	}

	private void getIniFile() {
		String line = null;
		try {
			StringBuffer strB = new StringBuffer();
			while ((strB = this.GetLine()) != null) {
				line = strB.toString().trim();
				logger.debug(line);
				int intLineLength = line.length();
				if (intLineLength <= 0 || line.startsWith(";")) {
					continue;
				}

				if (line.startsWith("[")) {
					if (!line.endsWith("]")) {
						throw new JobSchedulerException("] expected in section header: " + line);
					}
					String strSectionName = line.substring(1, intLineLength - 1).trim();
					if (strSectionName.length() > 0) {
						this.objCurrentSection = addSection(strSectionName);
					}
				}
				else {
					if (this.objCurrentSection == null) {
						throw new IOException("[sectionname]-header expected");
					}
					else {
						final int index = line.indexOf('=');
						if (index < 0) {
							throw new JobSchedulerException("key/value pair without =  : " + line);
						}

						final String strKey = line.substring(0, index).trim();
						final String strValue = line.substring(index + 1).trim();
						addEntry(strKey, strValue);
					}
				}
			} // while ((line = r.readLine()) != null)
			this.close();
			flgIsDirty = false;

		}
		catch (final Exception e) {
			throw new JobSchedulerException(e.toString() + "\n\nFile name is: " + strFileName);
		}
	}

	public SOSProfileEntry addEntry(final String strKey, final String strValue) {
		SOSProfileEntry objE = null;
		if (this.objCurrentSection == null) {
		}
		else {
			objE = this.objCurrentSection.addEntry(strKey, strValue);
		}
		return objE;
	}

	public SOSProfileSection addSection(final String pstrSectionName) {
		SOSProfileSection objNewSection = (SOSProfileSection) this.mapSections.get(pstrSectionName);
		if (objNewSection == null) {
			objNewSection = new SOSProfileSection(pstrSectionName);
			this.mapSections.put(pstrSectionName.toLowerCase(), objNewSection);
			flgIsDirty = true;
		}
		else {
			if (!this.flgIgnoreDuplicateSections) {
				throw new JobSchedulerException("Section '" + pstrSectionName + "' duplicated.");
			}
		}
		return objNewSection;
	}

	public SOSProfileSection getSection(final String pstrSectionName) {
		SOSProfileSection objNewSection = (SOSProfileSection) this.mapSections.get(pstrSectionName);
		return objNewSection;
	}

	private void setDirty() {
		this.flgIsDirty = true;
	}

	public boolean isDirty() {
		return this.flgIsDirty;
	}

	public Map<String, SOSProfileSection> Sections() {
		return this.mapSections;
	}

	public String Value(final String pstrEntryName) throws IOException {
		final String strDefaultValue = null;
		return this.getPropertyString(this.strSectionName, pstrEntryName, strDefaultValue);
	}

	public String Value(final String pstrEntryName, final String pstrDefaultValue) throws IOException {
		return this.getPropertyString(this.strSectionName, pstrEntryName, pstrDefaultValue);
	}

	public void setValue(final String pstrEntryName, final String pstrEntryValue) {
		/* das geht wohl noch nicht */
	}

	public void SectionName(final String pstrSectionName) {
		this.strSectionName = pstrSectionName;
	}

	public String SectionName() {
		return this.strSectionName;
	}

	public String getPropertyString(final String pstrSection, final String key, final String defaultValue) {
		if (pstrSection == null) {
			throw new JobSchedulerException("[section] name missing");
		}

		final SOSProfileSection map = (SOSProfileSection) this.mapSections.get(pstrSection.toLowerCase());
		if (map != null) {
			final SOSProfileEntry objPE = map.Entry(key.toLowerCase());
			if (objPE != null) {
				return objPE.Value();
			}
		}
		return defaultValue;
	}

	public int getPropertyInt(final String section, final String key, final int defaultValue) {
		final String s = this.getPropertyString(section, key, null);
		if (s != null) {
			return Integer.parseInt(s);
		}
		return defaultValue;
	}

	public boolean getPropertyBool(final String pstrSection, final String key, final boolean defaultValue) {
		final String s = this.getPropertyString(pstrSection, key, null);
		if (s != null) {
			return s.equalsIgnoreCase("true");
		}
		return defaultValue;
	}

	/**
	 * @return
	 */
	public String ProfileName() {
		return this.strFileName;
	}

	/**
	 * @param string
	 */
	public void ProfileName(final String pstrProfileName) {
		this.strFileName = pstrProfileName;
	}

	@Override
	public String toString() {
		String strT = "";

		int j = 0;
		for (final Iterator i = this.Sections().entrySet().iterator(); i.hasNext();) {
			final Map.Entry e = (Map.Entry) i.next();
			logger.debug(j++ + ": " + e.getKey());
			final SOSProfileSection objPS = (SOSProfileSection) e.getValue();
			logger.debug(objPS.Name() + " - " + objPS.Entries().size());
			strT = strT.concat(objPS.toString());
			// System.out.println ("Section " + ++j + ", Name = " + e.getKey());
			// Map m = (Map) e.getValue();
			// System.out.println ("         noOfEntries = " + m.size());
		}
		return strT;
	}

	public void saveAs(final String pstrSaveAsFileName) {
		logger.debug("SaveAs = " + pstrSaveAsFileName);
		objSaveFile = new JSTextFile(pstrSaveAsFileName);
		this.save(objSaveFile);
	}

	public void save() {
		objSaveFile = new JSTextFile(strFileName);
		this.save(objSaveFile);
	}

	public void save(final JSTextFile pobjSaveFile1) {
		Map<String, SOSProfileSection> objS = this.Sections();
		logger.debug("number of sections = " + objS.size());
		try {
			for (SOSProfileSection objPS : objS.values()) {
				pobjSaveFile1.WriteLine(" ");
				pobjSaveFile1.WriteLine("[" + objPS.Name() + "]");
				logger.debug(objPS.Name());
				for (SOSProfileEntry objEntry : objPS.Entries().values()) {
					pobjSaveFile1.WriteLine(objEntry.Name() + "=" + objEntry.Value());
					logger.debug("     " + objEntry.Name() + " = " + objEntry.Value());
				}
			}
			pobjSaveFile1.close();
			logger.debug("File saved " + pobjSaveFile1.getAbsolutePath());
		}
		catch (Exception e) {
			throw new JobSchedulerException(e.getLocalizedMessage());
		}

	}
}
