/********************************************************* begin of preamble
**
** Copyright (C) 2003-2012 Software- und Organisations-Service GmbH. 
** All rights reserved.
**
** This file may be used under the terms of either the 
**
**   GNU General Public License version 2.0 (GPL)
**
**   as published by the Free Software Foundation
**   http://www.gnu.org/licenses/gpl-2.0.txt and appearing in the file
**   LICENSE.GPL included in the packaging of this file. 
**
** or the
**  
**   Agreement for Purchase and Licensing
**
**   as offered by Software- und Organisations-Service GmbH
**   in the respective terms of supply that ship with this file.
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
** IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
** THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
** PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
** BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
** CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
** SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
** INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
** CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
** ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
** POSSIBILITY OF SUCH DAMAGE.
********************************************************** end of preamble*/
package com.sos.jobnet.dispatcher;

import com.sos.JSHelper.io.Files.JSFile;
import com.sos.i18n.I18NBase;
import com.sos.jobnet.classes.*;
import com.sos.jobnet.db.*;
import com.sos.jobnet.interfaces.IDispatchHandler;
import com.sos.jobnet.interfaces.IJobNetCollection;
import com.sos.jobnet.interfaces.IJobNetPlanEventListener;
import com.sos.jobnet.interfaces.IPlanItem;
import com.sos.jobnet.options.JobNetOptions;
import org.apache.log4j.Logger;

import java.io.File;
import java.util.List;

/**
* \class JobNetDBDispatcher 
* 
* \brief JobNetDBDispatcher - 
* 
* \details
*
* \section JobNetDBDispatcher.java_intro_sec Introduction
*
* \section JobNetDBDispatcher.java_samples Some Samples
*
* \code
*   .... code goes here ...
* \endcode
*
* <p style="text-align:center">
* <br />---------------------------------------------------------------------------
* <br /> APL/Software GmbH - Berlin
* <br />##### generated by ClaviusXPress (http://www.sos-berlin.com) #########
* <br />---------------------------------------------------------------------------
* </p>
* \author oh
* @version $Id: JobNetDBDispatcher.java 21040 2013-09-09 16:51:14Z ss $
* \see reference
*
* Created on 22.02.2012 13:56:28
 */
/**
 * @author oh
 *
 */
public class JobNetDBDispatcher  extends I18NBase  implements IDispatchHandler {

	private final String	conClassName	= "JobNetDBDispatcher";
	public  final String	conSVNVersion	= "$Id: JobNetDBDispatcher.java 21040 2013-09-09 16:51:14Z ss $";
	
 	private static final Logger	logger					= Logger.getLogger(JobNetDBDispatcher.class);
	private IJobNetCollection 	dispatchNodes 		    = new JobNetCollection();
	private IJobNetPlanEventListener eventListener = null;
	
	private static final String	JOBNETDBW_E_0010		= "JOBNETDBW_E_0010";		// %s: No item found for the current node (%s) in database table SCHEDULER_JOB_NET_PLAN.
 	
	private final JobNetOptions options;
	private final File configurationFile;

	private final JobNetNodeDBLayer jobNetNodeDBLayer;
	private final JobNetPlanDBLayer jobNetPlanDBLayer;
    private final JobNetEdgesDBLayer jobNetEdgesDBLayer;
    private final EventsDBLayer eventsDBLayer;
    private final JobNetHistoryDBLayer historyDBLayer;

    private final String uuidJobnetIdentifier;
    private final String jobNet;
    private final String schedulerId;
    private final JSFile hibernateConnectionConfigFile;
    private final String currentNode;
    private final String currentNodeTitle;
	private final JobNetPlanDBItem	currentRecord;

	
	public JobNetDBDispatcher(JobNetOptions jobNetOptions) {
		super(JobNetConstants.strBundleBaseName);
		this.options = jobNetOptions;
		this.configurationFile 	= new File(options.hibernate_connection_config_file.Value());
	    this.jobNetPlanDBLayer 	= new JobNetPlanDBLayer(configurationFile, options.scheduler_id.Value());
		this.jobNetEdgesDBLayer = new JobNetEdgesDBLayer(configurationFile);
		this.jobNetNodeDBLayer = new JobNetNodeDBLayer(configurationFile, options.scheduler_id.Value());
		this.historyDBLayer = new JobNetHistoryDBLayer(configurationFile, options.scheduler_id.Value());
		this.uuidJobnetIdentifier = options.uuid_jobnet_identifier.Value();
		this.jobNet = options.jobnet.Value();
		this.currentNode = options.node.Value();
		this.schedulerId = options.scheduler_id.Value();
		this.hibernateConnectionConfigFile = options.hibernate_connection_config_file.JSFile();
		this.currentNodeTitle = getNodeTitle();
		logOptions();

		this.currentRecord = readCurrentRecordFromDBAndLock();
		this.eventsDBLayer = new EventsDBLayer(hibernateConnectionConfigFile);
	}

	private void logOptions() {
		final String conMethodName = conClassName + "::logOptions";
		logger.debug(Messages.getMsg(JobNetConstants.JOBNET_D_0001, conMethodName, "uuid_jobnet_identifier", uuidJobnetIdentifier));
		logger.debug(Messages.getMsg(JobNetConstants.JOBNET_D_0001, conMethodName, "jobnet", jobNet));
		logger.debug(Messages.getMsg(JobNetConstants.JOBNET_D_0001, conMethodName, "node", currentNode));
		logger.debug(Messages.getMsg(JobNetConstants.JOBNET_D_0001, conMethodName, "scheduler_id", schedulerId));
		logger.debug(Messages.getMsg(JobNetConstants.JOBNET_D_0001, conMethodName, "hibernate_connection_config_file", hibernateConnectionConfigFile.getAbsolutePath()));
	}
	
	/**
	 * \brief getCurNode
	 * 
	 * \details
	 */
	private JobNetPlanDBItem readCurrentRecordFromDBAndLock() {

		final String conMethodName = conClassName + "::setCurrentRecord";
		JobNetPlanDBItem result = null;
		JobNetPlanFilter jobNetPlanFilter = new JobNetPlanFilter();
		jobNetPlanFilter.setSchedulerId(schedulerId);
		jobNetPlanFilter.setUuid(uuidJobnetIdentifier);
		jobNetPlanFilter.setJobnet(jobNet);
		jobNetPlanFilter.setNode(currentNode);
		jobNetPlanDBLayer.setFilter(jobNetPlanFilter);
		
		List<JobNetPlanDBItem> jobNetPlanDBItem  = jobNetPlanDBLayer.getJobnetPlanListWithLock(0);
		if(jobNetPlanDBItem == null || jobNetPlanDBItem.isEmpty()) {
			String msg = Messages.getMsg(JOBNETDBW_E_0010, conMethodName, currentNodeTitle);
			logger.error(msg);
			throw new JobNetException(msg);
		}
		else {
			result = jobNetPlanDBItem.get(0);
			logger.debug(Messages.getMsg(JobNetConstants.JOBNET_D_0010, conMethodName, result.getTitle()));
		}
		return result;
		
	}

	/**
	 * A jobnet is defined as finished if all nodes in FINISHED or ERROR state.
	 */
	@Override
	public boolean isJobnetEnded() {
		return jobNetPlanDBLayer.isJobnetEnded(uuidJobnetIdentifier);
	}

	private JobNetPlanDBItem getCurrentRecord() {
		return currentRecord;
	}
	
	private String getNodeTitle() {
		return uuidJobnetIdentifier + "/" + schedulerId + ":" + jobNet + ":" + currentNode;
	}
	
	/**
	 * \brief updateDispatcherStatus
	 * 
	 * \details
	 *
	 * @param status
	 */
	private void updateDispatcherStatus(NodeStatus status) {
		JobNetPlanDBItem record = getCurrentRecord();
		int oldState = record.getStatusDispatcher();
		record.setStatusDispatcher(status.getIndex());
		update();
		if (eventListener != null)
			eventListener.dispatcherStatusChanged(status, NodeStatus.valueOf(oldState));
 	}
	
	
	/**
	 * \brief updateRunnerStatus
	 * 
	 * \details
	 *
	 * @param status
	 */
	private void updateRunnerStatus(NodeStatus status) {
		JobNetPlanDBItem record = getCurrentRecord();
		int oldState = record.getStatusRunner();
 		record.setStatusRunner(status.getIndex());
		update();
		if (eventListener != null)
			eventListener.runnerStatusChanged(status, NodeStatus.valueOf(oldState));
 	} // private void updateRunnerStatus
	
	
	/**
	 * \brief updateNodeStatus
	 * 
	 * \details
	 *
	 * @param status
	 */
	private void updateNodeStatus(NodeStatus status) {
		JobNetPlanDBItem rec = getCurrentRecord();
		int oldState = rec.getStatusNode();
		rec.setStatusNode(status.getIndex());
		update();
		nodeStatusChanged(rec, NodeStatus.valueOf(oldState) );
 	} // private void updateNodeStatus


    // update the status in the node_record
	private void updateNodeStatus(JobNetPlanDBItem planDBRecord, NodeStatus status) {
		int oldState = planDBRecord.getStatusNode();
		planDBRecord.setStatusNode(status.getIndex());
		jobNetPlanDBLayer.beginTransaction();
		jobNetPlanDBLayer.saveOrUpdate(planDBRecord);
		jobNetPlanDBLayer.commit();
		nodeStatusChanged(planDBRecord, NodeStatus.valueOf(oldState) );
 	}

	/**
	 * \brief update
	 * 
	 * \details
	 */
	private void update() {
		@SuppressWarnings("unused")
		final String conMethodName = conClassName + "::update";
		jobNetPlanDBLayer.beginTransaction();
		jobNetPlanDBLayer.saveOrUpdate(getCurrentRecord());
		jobNetPlanDBLayer.commit();
	} // private void update

	
	/**
	 * \brief setDispatcherStatusToRunning
	 * 
	 * \details
	 */
	@Override
	public void setDispatcherStatusToRunning() {
		updateDispatcherStatus(NodeStatus.RUNNING);
	}

	/**
	 * \brief isDispatcherSkipped
	 * 
	 * \details
	 *
	 * \return 
	 *
	 * @return boolean
	 */
	@Override
	public boolean isDispatcherSkipped() {
		@SuppressWarnings("unused")
		final String conMethodName = conClassName + "::isDispatcherSkipped";
		return getCurrentRecord().getIsDispatcherSkipped();
	}

	/**
	 * \brief setRunnerStatusToRunning
	 * 
	 * \details
	 */
	@Override
	public void setRunnerStatusToFinished() {
		updateRunnerStatus(NodeStatus.FINISHED);
	}

	/**
	 * \brief setDispatcherStatusToFinish
	 * 
	 * \details
	 */
	@Override
	public void setDispatcherStatusToFinished() {
		updateDispatcherStatus(NodeStatus.FINISHED);
	}

	/**
	 * \brief setDispatcherStatusToError
	 * 
	 * \details
	 */
	@Override
	public void setDispatcherStatusToError() {
		updateDispatcherStatus(NodeStatus.ERROR);
	}

	@Override
	public void setRunnerStatusToError() {
		updateRunnerStatus(NodeStatus.ERROR);
		
	}

	@Override
	public boolean isRunnerSkipped() {
		@SuppressWarnings("unused")
		final String conMethodName = conClassName + "::isRunnerSkipped";
		return getCurrentRecord().getIsRunnerSkipped();	
	}

    @Override
    public boolean isRunnerInError() {
        NodeStatus state = NodeStatus.valueOf(getCurrentRecord().getStatusRunner());
        return state == NodeStatus.ERROR;
    }


    @Override
	public int getNumberOfDispatchingNodes() {
		return dispatchNodes.size();
	}

	@Override
	public IJobNetCollection getDispatchingNodes() {

		final String conMethodName = conClassName + "::getDispatchforNodes";
		// getCurNode();

        logger.info("Collecting nodes to dispatch");
		List<JobNetEdgesDBItem> jobnetEdgesList = jobNetEdgesDBLayer.getSuccessors(getCurrentRecord().getJobnetNodeDBItem()); 

		for (JobNetEdgesDBItem jobnetEdgesItem : jobnetEdgesList) {
			
			JobNetNodeDBItem jobNetNodeDBItem = jobNetNodeDBLayer.getNode(jobnetEdgesItem.getChildNodeId());
			Long successor = jobNetNodeDBItem.getNodeId();
			
			JobNetPlanFilter jobNetPlanFilter = new JobNetPlanFilter();
			jobNetPlanDBLayer.setFilter(jobNetPlanFilter);
			
			jobNetPlanDBLayer.getFilter().setNodeId(successor);
			jobNetPlanFilter.setSchedulerId(schedulerId);
			jobNetPlanFilter.setUuid(uuidJobnetIdentifier);
			jobNetPlanFilter.setJobnet(jobNet);
			
			JobNetPlanDBItem jobnetPlanDBItem = jobNetPlanDBLayer.getJobnetPlanList(0).get(0);
			NodeStatus status = NodeStatus.valueOf(jobnetPlanDBItem.getStatusNode());
			logger.info(String.format("The node %1s has the status %2s", successor, status.name()));
            if (status.isNotProcessed()) {
                logger.info("Node " + jobnetPlanDBItem.getJobnetNodeDBItem().getNode() + " will be dispatched.");
				setNodeStatusToStarted(jobnetPlanDBItem);		// node has to block for other processes
                updateHistory();
				dispatchNodes.add(jobnetPlanDBItem);
			}else{
                logger.info("Node " + jobnetPlanDBItem.getJobnetNodeDBItem().getNode() + " will NOT be dispatched - already running.");
			}
		}
		return dispatchNodes;
	}

	

	@Override
	public void open() {
		logger.debug(String.format("....Class: %s    conSVN: %s",conClassName, conSVNVersion));
	    logger.debug(String.format("....Scheduler / Cluster: %s",options.scheduler_id.Value()));
		logger.debug(String.format("....Using hibernate configuration file: %s",hibernateConnectionConfigFile.getAbsoluteFile()));
	    logger.debug(String.format("....Dispatching node: %s in jobnet %s",currentNode,jobNet));
 	}

	@Override
	public void close() {
		logger.debug(String.format("\n..........Dispatching finished"));
	    this.jobNetPlanDBLayer.closeSession();
		this.jobNetEdgesDBLayer.closeSession();
		this.jobNetNodeDBLayer.closeSession();
	}

    /*
	@Override
	public void setNodeStatusToStarting(JobNetPlanDBItem planItem) {
		updateNodeStatus(planItem, enuStatus.STARTING);
	}
	*/

	@Override
	public void setNodeStatusToStarted(JobNetPlanDBItem planItem) {
		updateNodeStatus(planItem, NodeStatus.STARTED);
	}

    @Override
    public void setNodeStatusToFinished() {
        updateNodeStatus(NodeStatus.FINISHED);
    }

    @Override
    public void setNodeStatusToDispatching() {
        updateNodeStatus(NodeStatus.DISPATCHING);
    }

    @Override
    public void setNodeStatusToError(long exitCode) {
        JobNetPlanDBItem rec = getCurrentRecord();
        rec.setExitCode(exitCode);
        updateNodeStatus(rec, NodeStatus.ERROR);
    }

    @Override
    public void setSkipRunner() {
        JobNetPlanDBItem rec = getCurrentRecord();
        rec.setIsRunnerSkipped(true);
        jobNetPlanDBLayer.saveOrUpdate(rec);
        jobNetPlanDBLayer.commit();
    }

    /*
    @Override
    public void setNodeStatusToError() {
        updateNodeStatus(enuStatus.ERROR);
    }
    */

	public void nodeStatusChanged(IPlanItem node, NodeStatus oldState) {
		if(eventListener != null) {
			eventListener.nodeStatusChanged(node, oldState);
		}
	}

    // update the history record for the jobnetz
    @Override
    public void updateHistory() {
        historyDBLayer.updateHistory( getCurrentRecord().getJobNetHistoryDBItem() );
    }

    @Override
	public void setNodeStatusListener(IJobNetPlanEventListener listener) {
		this.eventListener = listener;
	}
	
	@Override
	public void createEvent(EventsDBItem record) {
		eventsDBLayer.createEvent(record);
	}
	
}
