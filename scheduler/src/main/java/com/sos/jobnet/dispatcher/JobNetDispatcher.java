/**
 * Copyright (C) 2014 BigLoupe http://bigloupe.github.io/SoS-JobScheduler/
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License
 */
/********************************************************* begin of preamble
**
** Copyright (C) 2003-2012 Software- und Organisations-Service GmbH. 
** All rights reserved.
**
** This file may be used under the terms of either the 
**
**   GNU General Public License version 2.0 (GPL)
**
**   as published by the Free Software Foundation
**   http://www.gnu.org/licenses/gpl-2.0.txt and appearing in the file
**   LICENSE.GPL included in the packaging of this file. 
**
** or the
**  
**   Agreement for Purchase and Licensing
**
**   as offered by Software- und Organisations-Service GmbH
**   in the respective terms of supply that ship with this file.
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
** IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
** THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
** PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
** BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
** CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
** SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
** INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
** CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
** ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
** POSSIBILITY OF SUCH DAMAGE.
********************************************************** end of preamble*/
package com.sos.jobnet.dispatcher;
import com.sos.jobnet.classes.JobNetException;
import com.sos.jobnet.classes.NodeStatus;
import com.sos.jobnet.db.EventsDBItem;
import com.sos.jobnet.db.JobNetPlanDBItem;
import com.sos.jobnet.interfaces.*;
import com.sos.jobnet.options.JobNetOptions;
import com.sos.jobnet.waiter.JobNetWaiter;
import org.apache.log4j.Level;
import org.apache.log4j.Logger;

import java.util.HashMap;

/**
* \class JobNetDispatcher 
* 
* \brief JobNetDispatcher - 
* 
* \details
*
* \section JobNetDispatcher.java_intro_sec Introduction
*
* \section JobNetDispatcher.java_samples Some Samples
*
* \code
*   .... code goes here ...
* \endcode
*
* <p style="text-align:center">
* <br />---------------------------------------------------------------------------
* <br /> APL/Software GmbH - Berlin
* <br />##### generated by ClaviusXPress (http://www.sos-berlin.com) #########
* <br />---------------------------------------------------------------------------
* </p>
* \author Uwe Risse
* @version $Id: JobNetDispatcher.java 21040 2013-09-09 16:51:14Z ss $
* \see reference
*
* Created on 24.02.2012 13:02:19
 */
/**
 * @author Uwe Risse
 *
 */
public class JobNetDispatcher implements IJobNetCallback, IJobNetPlanEventListener {

	public  final String	conSVNVersion	= "$Id: JobNetDispatcher.java 21040 2013-09-09 16:51:14Z ss $";
	private final String		conClassName		= "JobNetDispatcher";
	private static final Logger	logger				= Logger.getLogger(JobNetDispatcher.class);
	private IDispatchHandler	objDispatchHandler	= null;
	private JobNetOptions		objOptions			= null;

	private IJobNetCallback objJobNetCallback = this;

	public JobNetDispatcher() {
	}
	
	public void setIJobNetCallback(IJobNetCallback pobjJobNetCallback) {
		objJobNetCallback = pobjJobNetCallback;
	}
	
	public JobNetOptions Options() {
		@SuppressWarnings("unused")
		final String conMethodName = conClassName + "::Options";
		if (objOptions == null) {
			objOptions = new JobNetOptions();
		}
		return objOptions;
	} // public JobNetOptions Options

	public void setOptions(JobNetOptions objOptions) {
		this.objOptions = objOptions;
	}
	
	public void setOptionsUsingHashMap(HashMap<String, String> objHshMap) {
		@SuppressWarnings("unused")
		final String conMethodName = conClassName + "::setOptionsUsingHashMap";
		try {
			Options().setAllOptions(objHshMap);
		}
		catch (Exception e) {
 			e.printStackTrace();
		}
	} // public void setOptionsUsingHashMap

	public void doInit() {
		@SuppressWarnings("unused")
		final String conMethodName = conClassName + "::doInit";
		objDispatchHandler = new JobNetDBDispatcher(objOptions);
		objDispatchHandler.setNodeStatusListener(this);
	} // public void doInit

	public JobNetDispatcher run() {
		@SuppressWarnings("unused")
		final String conMethodName = conClassName + "::run";
		objDispatchHandler.open();
		boolean continueDispatcher = true;

 		try {
            if (objOptions.restart_option.isContinueIgnore() && objDispatchHandler.isRunnerInError()) {
                objJobNetCallback.log(Level.INFO,"A previous error of the node ignored, because 'RestartOption' was set to " + objOptions.restart_option.Value() + ".");
            } else {
                if (objDispatchHandler.isRunnerSkipped()) {
                    objDispatchHandler.setRunnerStatusToFinished();
                } else {
                    int exitCode = objJobNetCallback.getExitCode();
                    objJobNetCallback.log(Level.INFO,"The exit_code of the script is " + exitCode);
                    if (!Options().valid_errors.IsEmpty())
                        objJobNetCallback.log(Level.INFO,"Valid errors are " + Options().valid_errors.Value());
                    if ( exitCode!=0 && !Options().valid_errors.contains(exitCode) ) {
                        objDispatchHandler.setNodeStatusToError(exitCode);
                        continueDispatcher = false;
                        if ( Options().valid_errors.contains(exitCode) )
                            objDispatchHandler.setRunnerStatusToFinished();
                        else
                            objDispatchHandler.setRunnerStatusToError();
                    }
                }
            }
		} catch (Exception e) {
			objDispatchHandler.setDispatcherStatusToError();
			objDispatchHandler.setNodeStatusToError(0);
			String msg = "Error processing dispatcher.";
			logger.error(msg,e);
			throw new JobNetException(msg, e);
		}
        objDispatchHandler.updateHistory();

		if (continueDispatcher) {
	 		try {
				objDispatchHandler.setDispatcherStatusToRunning();
				objDispatchHandler.setNodeStatusToDispatching();
			    dispatch();
				objDispatchHandler.setNodeStatusToFinished();
                // objDispatchHandler.setSkipRunner();
				objDispatchHandler.setDispatcherStatusToFinished();
                objDispatchHandler.updateHistory();
			}
			catch (Exception e) {
				objDispatchHandler.setDispatcherStatusToError();
				objDispatchHandler.setNodeStatusToError(0);
				String msg = "Error processing dispatcher.";
				logger.error(msg,e);
				throw new JobNetException(msg, e);
			}
		}

		objDispatchHandler.close();
		objJobNetCallback.log(Level.INFO,"Dispatcher is finished.");
		
		boolean jobnetEnded = objDispatchHandler.isJobnetEnded();;
		if (jobnetEnded) {
			objJobNetCallback.jobnetEnded(this);
		}
		return this;
	} // public JobNetDispatcher run
	
	public void createEvent(String eventId) {
		String uuid = Options().uuid_jobnet_identifier.Value();
		EventsDBItem eventRecord = objJobNetCallback.createEventRecord(uuid, eventId);
		objDispatchHandler.createEvent(eventRecord);
	}

	
	@SuppressWarnings("unused")
	private void sleep(int sleepTime){
 		 
		try {
			if (sleepTime > 0) {
				String msg = String.format("Dispatcher is going to sleep for %1s seconds",sleepTime);
				objJobNetCallback.log(Level.DEBUG,msg);	
				Thread.sleep(sleepTime*1000);
			}
		} catch (InterruptedException e) {
			String msg = "Sleep interrupted.";
			logger.error(msg);
			objJobNetCallback.log(Level.ERROR, msg, e);
			throw new JobNetException(msg, e);
		}
	}
	
	private void dispatch(){
 		
		// sleep(objOptions.delay_start_dispatcher.getTimeAsSeconds());
		IJobNetCollection jobNetCollection = objDispatchHandler.getDispatchingNodes();
		for(int i = 0; i < jobNetCollection.size();i++){
			JobNetPlanDBItem planItem = (JobNetPlanDBItem)jobNetCollection.get(i);
			objJobNetCallback.startNode(planItem, Options());
			// objDispatchHandler.setNodeStatusToStarted(planItem);
 		}
	}

	@Override
	public int getExitCode() {
		// TODO Auto-generated method stub
		return 0;
	}

    @Override
    public void setNextState() {
        //To change body of implemented methods use File | Settings | File Templates.
    }

    @Override
	public void log(Level level, String message, Throwable error) {
		logger.log(level, message, error);
	}

	@Override
	public void log(Level level, String message) {
		logger.log(level, message);
	}

	@Override
	public void setStateText(String stateText) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void startNode(IPlanItem planItem, JobNetOptions options) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void skipRunner() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void logStatus(IPlanItem record, NodeStatus oldStatus) {
        NodeStatus status = NodeStatus.valueOf(record.getStatusNode());
		logger.info("Node status of id " + record.getNodeId() +  " is set from " + oldStatus.name() + " to " + status.name());
	}

	@Override
	public void nodeStatusChanged(IPlanItem node, NodeStatus oldState) {
		objJobNetCallback.logStatus(node, oldState);
	}

	@Override
	public void waiterStatusChanged(NodeStatus newState, NodeStatus oldState) {
		// not implemented
	}

	@Override
	public void runnerStatusChanged(NodeStatus newState, NodeStatus oldState) {
		objJobNetCallback.logContextStatus("RUNNER", oldState, newState);
	}

	@Override
	public void dispatcherStatusChanged(NodeStatus newState, NodeStatus oldState) {
		objJobNetCallback.logContextStatus("DISPATCHER", oldState, newState);
	}

	@Override
	public void logContextStatus(String context, NodeStatus fromStatus, NodeStatus toStatus) {
		String msg = context + " changed from  " + fromStatus.name() +  " to " + toStatus.name();
		logger.info(msg);
	}

	@Override
	public EventsDBItem createEventRecord(String forEventClass,	String forEventId) {
		// has to be implemented in the callback class.
		return null;
	}

	@Override
	public void jobnetStarted(JobNetWaiter waiter) {
		// has to be implemented in the callback class.
	}

	@Override
	public void jobnetEnded(JobNetDispatcher dispatcher) {
		// has to be implemented in the callback class.
	}
}
