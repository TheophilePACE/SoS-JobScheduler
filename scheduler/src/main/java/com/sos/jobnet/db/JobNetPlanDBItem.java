/**
 * Copyright (C) 2014 BigLoupe http://bigloupe.github.io/SoS-JobScheduler/
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License
 */
/********************************************************* begin of preamble
**
** Copyright (C) 2003-2012 Software- und Organisations-Service GmbH. 
** All rights reserved.
**
** This file may be used under the terms of either the 
**
**   GNU General Public License version 2.0 (GPL)
**
**   as published by the Free Software Foundation
**   http://www.gnu.org/licenses/gpl-2.0.txt and appearing in the file
**   LICENSE.GPL included in the packaging of this file. 
**
** or the
**  
**   Agreement for Purchase and Licensing
**
**   as offered by Software- und Organisations-Service GmbH
**   in the respective terms of supply that ship with this file.
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
** IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
** THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
** PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
** BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
** CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
** SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
** INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
** CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
** ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
** POSSIBILITY OF SUCH DAMAGE.
********************************************************** end of preamble*/
package com.sos.jobnet.db;

/**
* \class JobnetPlanDBItem 
* 
* \brief JobnetPlanDBItem - 
* 
* \details
*
* \section JobnetPlanDBItem.java_intro_sec Introduction
*
* \section JobnetPlanDBItem.java_samples Some Samples
*
* \code
*   .... code goes here ...
* \endcode
*
* <p style="text-align:center">
* <br />---------------------------------------------------------------------------
* <br /> APL/Software GmbH - Berlin
* <br />##### generated by ClaviusXPress (http://www.sos-berlin.com) #########
* <br />---------------------------------------------------------------------------
* </p>
* \author Uwe Risse
* \version 23.09.2011
* \see reference
*
* Created on 23.09.2011 15:08:05
 */

import com.sos.hibernate.classes.DbItem;
import com.sos.jobnet.interfaces.INodesItem;
import com.sos.jobnet.interfaces.IPlanItem;
import org.hibernate.annotations.NotFound;
import org.hibernate.annotations.NotFoundAction;

import javax.persistence.*;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
 

@Entity
@Table(name="SCHEDULER_JOB_NET_PLAN",
uniqueConstraints = {@UniqueConstraint(columnNames={"UUID", "NODE_ID"})})

public class JobNetPlanDBItem extends DbItem implements IPlanItem{
	
	@SuppressWarnings("unused")
	 private final String	conClassName	= "JobNetPlanDBItem";
	 public  final String	conSVNVersion	= "$Id: JobNetPlanDBItem.java 21046 2013-09-10 07:49:01Z ur $";

	 private static final String NOW = "now";
	 private JobNetPlanDBItem connectorNodeDBItem = null;
	 private JobNetPlanDBItem subnetNodeDBItem = null;
	 private JobNetNodeDBItem jobnetNodeDBItem = null;
     private Long planId;
     private Long historyId; 
	 private String uuid;
     private Long nodeId;
     private Long subnetId;
     private Long connectorId;
     private Long taskId;
	 private Long exitCode;
     private String exitMessage;
     private String nodeType;
     private String scriptToExecute;
     private Boolean useErrorHandler;
	 private Integer statusWaiter;
	 private Integer statusRunner;
	 private Integer statusDispatcher;
	 private Boolean isWaiterSkipped;
	 private Boolean isRunnerSkipped;
     private Boolean isDispatcherSkipped;
     private Boolean isRunnerOnDemand;
	 private Integer status;
	 private Date plannedStartTime;
	 private Date startTime;
	 private Date endTime;
	 private Boolean bootstrap;
	 private Boolean frequencyOverwrite;
	 private String message;
	 private String orderXml;
	 private Date created;
	 private String createdBy;
	 private Date modified;
	 private String modifiedBy;
  	 
  	 public String dateFormat="yyyy-MM-dd HH:mm";
     private JobNetHistoryDBItem jobNetHistoryDBItem;
     private JobNetNodeDBItem jobNetNodeDBItem;


 	public JobNetPlanDBItem(String dateFormat_) {
		this.dateFormat = dateFormat_;
	}
	
 	public JobNetPlanDBItem() {
 	   super();
 	}
	
 	
    @Id
    @GeneratedValue(strategy=GenerationType.AUTO)
    @Column(name="PLAN_ID")
    public Long getPlanId() {
		return planId;
	}

    @Column(name="PLAN_ID")
	public void setPlanId(Long planId) {
		this.planId = planId;
	}
    
    
    @ManyToOne (optional=true)
    @NotFound( action = NotFoundAction.IGNORE )
    @JoinColumn (name="`NODE_ID`", insertable = false, updatable = false)
    public JobNetNodeDBItem getJobNetNodeDBItem() {
        return jobNetNodeDBItem;
    }
    
    public void setJobNetNodeDBItem(JobNetNodeDBItem jobNetNodeDBItem)  {
       this.jobNetNodeDBItem = jobNetNodeDBItem; 
    }
    
    @Column(name="NODE_ID", updatable = false, insertable = false) 
    public Long getNodeId() {
        return nodeId;
    }

      
    @Column(name="NODE_ID", updatable = false, insertable = false) 
    public void setNodeId(Long nodeId) {
        this.nodeId = nodeId;
    }

    @Column(name="SUBNET_ID", nullable = false)
    public Long getSubnetId() {
        return subnetId;
    }


    @Column(name="SUBNET_ID", nullable = false)
    public void setSubnetId(Long subnetId) {
        this.subnetId = subnetId;
    }

    @ManyToOne (optional=true)
    @NotFound( action = NotFoundAction.IGNORE )
    @JoinColumn (name="SUBNET_ID", referencedColumnName="PLAN_ID", insertable = false, updatable = false)
    public JobNetPlanDBItem getSubNetNodeDBItem() {
        return subnetNodeDBItem;
    }
    public void setSubNetNodeDBItem(JobNetPlanDBItem subnetNodeDBItem)  {
        this.subnetNodeDBItem = subnetNodeDBItem;
    }

    @Column(name="CONNECTOR_ID", nullable = false)
    public Long getConnectorId() {
        return connectorId;
    }


    @Column(name="CONNECTOR_ID", nullable = false)
    public void setConnectorId(Long connectorId) {
        this.connectorId = connectorId;
    }

    @ManyToOne (optional=true)
    @NotFound( action = NotFoundAction.IGNORE )
    @JoinColumn (name="CONNECTOR_ID", referencedColumnName="PLAN_ID", insertable = false, updatable = false)
    public JobNetPlanDBItem getConnectorNodeDBItem() {
        return connectorNodeDBItem;
    }
    public void setConnectorNodeDBItem(JobNetPlanDBItem connectorNodeDBItem)  {
        this.connectorNodeDBItem = subnetNodeDBItem;
    }

    @Column(name="USE_ERROR_HANDLER",nullable=false)
    public void setUseErrorHandler(Boolean useErrorHandler) {
        this.useErrorHandler = useErrorHandler;
    }

    @Column(name="USE_ERROR_HANDLER",nullable=false)
    public Boolean getUseErrorHandler() {
        return useErrorHandler;
    }

    @ManyToOne (optional=true)
    @NotFound( action = NotFoundAction.IGNORE )
    @JoinColumn (name="`HISTORY_ID`", insertable = false, updatable = false)
    public JobNetHistoryDBItem getJobNetHistoryDBItem() {
        return jobNetHistoryDBItem;
    }
    
    public void setJobNetHistoryDBItem(JobNetHistoryDBItem jobNetHistoryDBItem)  {
       this.jobNetHistoryDBItem = jobNetHistoryDBItem;
    }

    @Column(name="HISTORY_ID",nullable=true)
    public void setHistoryId(long historyId) {
        this.historyId = historyId;
    }
 
    @Column(name="HISTORY_ID",nullable=true)
    public long getHistoryId() {
        return historyId;
    } 
 
    @ManyToOne (optional=false)
    @JoinColumn(name="NODE_ID")
    public   JobNetNodeDBItem getJobnetNodeDBItem() {
    	return jobnetNodeDBItem;
    }
    public void setJobnetNodeDBItem(JobNetNodeDBItem  jobnetNodeDBItem) {
    	this.jobnetNodeDBItem = jobnetNodeDBItem;
    }
    
   
    
    @Column(name="UUID",nullable=false)
	public void setUuidId(String uuid) {
		this.uuid = uuid;
	}
    
    @Column(name="UUID",nullable=true)
	public String getUuid() {
		return uuid;
	}
    
 
    @Column(name="EXIT_CODE",nullable=false)
	public void setExitCode(Long exitCode) {
		this.exitCode = exitCode;
	}
 
    @Column(name="EXIT_CODE",nullable=false)
	public Long getExitCode() {
		return exitCode;
	}

    
    @Column(name="EXIT_MESSAGE",nullable=true)
	public void setExitMessage(String exitMessage) {
		this.exitMessage = exitMessage;
	}
 
    @Column(name="EXIT_MESSAGE",nullable=true)
	public String getExitMessage() {
		return exitMessage;
	}

    @Column(name="STATUS_WAITER",nullable=false)
	public void setStatusWaiter(Integer statusWaiter) {
		this.statusWaiter = statusWaiter;
	}
 
    @Column(name="STATUS_WAITER",nullable=false)
	public Integer getStatusWaiter() {
		return statusWaiter;
	}

    @Column(name="STATUS_RUNNER",nullable=false)
	public void setStatusRunner(Integer statusRunner) {
		this.statusRunner = statusRunner;
	}
 
    @Column(name="STATUS_RUNNER",nullable=false)
	public Integer getStatusRunner() {
		return statusRunner;
	}
    
    @Column(name="STATUS",nullable=false)
	public void setStatusNode(Integer statusNode) {
		this.status = statusNode;
	}
 
    @Column(name="STATUS",nullable=false)
	public Integer getStatusNode() {
		return status;
	}
    
    @Column(name="STATUS_DISPATCHER",nullable=false)
	public void setStatusDispatcher(Integer statusDispatcher) {
		this.statusDispatcher = statusDispatcher;
	}
 
    @Column(name="STATUS_DISPATCHER",nullable=false)
	public Integer getStatusDispatcher() {
		return statusDispatcher;
	}

    @Column(name="BOOTSTRAP",nullable=false)
	public void setBootstrap(Boolean bootstrap) {
		this.bootstrap = bootstrap;
	}
 
    @Column(name="BOOTSTRAP",nullable=false)
	public Boolean getBootstrap() {
		return bootstrap;
	}
    
   
    
    @Column(name="FREQUENCE_OVERWRITE",nullable=false)
	public void setFrequencyOverwrite(Boolean frequencyOverwrite) {
		this.frequencyOverwrite = frequencyOverwrite;
	}
 
    @Column(name="FREQUENCE_OVERWRITE",nullable=false)
	public Boolean getFrequencyOverwrite() {
		return frequencyOverwrite;
	}
    
    @Column(name="MESSAGE",nullable=true)
	public void setMessage(String message) {
		this.message = message;
	}
 
    @Column(name="MESSAGE",nullable=true)
	public String getMessage() {
		return message;
	}
    
    @Column(name="IS_WAITER_SKIPPED",nullable=true)
	public void setIsWaiterSkipped(Boolean isWaiterSkipped) {
		this.isWaiterSkipped = isWaiterSkipped;
	}
 
    @Column(name="IS_WAITER_SKIPPED",nullable=true)
	public Boolean getIsWaiterSkipped() {
		return isWaiterSkipped;
	}
    
    @Column(name="IS_RUNNER_SKIPPED",nullable=true)
	public void setIsRunnerSkipped(Boolean isRunnerSkipped) {
		this.isRunnerSkipped = isRunnerSkipped;
	}
 
    @Column(name="IS_RUNNER_SKIPPED",nullable=true)
	public Boolean getIsRunnerSkipped() {
		return isRunnerSkipped;
	}
    
    @Column(name="IS_DISPATCHER_SKIPPED",nullable=true)
    public void setIsDispatcherSkipped(Boolean isDispatcherSkipped) {
        this.isDispatcherSkipped = isDispatcherSkipped;
    }
 
    @Column(name="IS_DISPATCHER_SKIPPED",nullable=true)
    public Boolean getIsDispatcherSkipped() {
        return isDispatcherSkipped;
    }
        
    @Column(name="IS_RUNNER_ON_DEMAND",nullable=true)
    public void setIsRunnerOnDemand(Boolean isRunnerOnDemand) {
        this.isRunnerOnDemand = isRunnerOnDemand;
    }
 
    @Column(name="IS_RUNNER_ON_DEMAND",nullable=true)
    public Boolean getIsRunnerOnDemand() {
        return isRunnerOnDemand;
    }
        
    @Column(name="NODE_TYPE",nullable=true)
    public void setNodeType(String nodeType) {
        this.nodeType = nodeType;
    }
 
    @Column(name="NODE_TYPE",nullable=true)
    public String getNodeType() {
        return nodeType;
    }
    
    
    @Column(name="TASK_ID",nullable=true)
    public void setTaskId(Long taskId) {
        this.taskId = taskId;
    }

    @Column(name="TASK_ID",nullable=true)
    public Long getTaskId() {
        return taskId;
    }
  
    @Lob
    @Column(name="ORDER_XML", nullable=true)
  	public String getOrderXml() {
  		return orderXml;
  	}
    
    @Lob
    @Column(name="ORDER_XML", nullable=true)
  	public void setOrderXml(String orderXml) {
  		this.orderXml = orderXml;
  	}
    
    @Temporal (TemporalType.TIMESTAMP)
    @Column(name="CREATED",nullable=true)
	public void setCreated(Date created) {
		this.created = created;
	}
    
    @Temporal(TemporalType.TIMESTAMP)
	@Column(name = "CREATED", nullable = true)
	public Date getCreated() {
		return created;
	}
    
    @Temporal (TemporalType.TIMESTAMP)
    @Column(name="MODIFIED",nullable=true)
	public void setModified(Date modified) {
		this.modified = modified;
	}
    
    @Column(name="CREATED_BY",nullable=true)
	public void setCreatedBy(String createdBy) {
		this.createdBy = createdBy;
	}
 
    @Column(name="CREATED_BY",nullable=true)
	public String getCreatedBy() {
		return createdBy;
	}
    
    @Column(name="MODIFIED_BY",nullable=true)
	public void setModifiedBy(String modifiedBy) {
		this.modifiedBy = modifiedBy;
	}
 
    @Column(name="MODIFIED_BY",nullable=true)
	public String getModifiedBy() {
		return modifiedBy;
	}

    @Temporal(TemporalType.TIMESTAMP)
	@Column(name = "MODIFIED", nullable = true)
	public Date getModified() {
		return modified;
	}

    @Temporal (TemporalType.TIMESTAMP)
    @Column(name="PLANNED_START_TIME",nullable=true)
	public void setPlannedStartTime(Date plannedStartTime) {
		this.plannedStartTime = plannedStartTime;
	}
    
    @Temporal(TemporalType.TIMESTAMP)
	@Column(name = "PLANNED_START_TIME", nullable = true)
	public Date getPlannedStartTime() {
		return plannedStartTime;
	}
    
   
    
    @Temporal (TemporalType.TIMESTAMP)
    @Column(name="END_TIME",nullable=true)
	public void setEndTime(Date endTime) {
		this.endTime = endTime;
	}
    
    @Temporal(TemporalType.TIMESTAMP)
	@Column(name = "END_TIME", nullable = true)
	public Date getEndTime() {
		return endTime;
	} 
    
    @Temporal(TemporalType.TIMESTAMP)
	@Column(name = "START_TIME", nullable = true)
    public Date getStartTime() {
		return startTime;
	}

    @Temporal(TemporalType.TIMESTAMP)
	@Column(name = "START_TIME", nullable = true)
    public void setStartTime(Date startTime) {
		this.startTime = startTime;
	}

	@Column(name = "UUID", nullable = false)
    public void setUuid(String uuid) {
		this.uuid = uuid;
	}

    @Column(name="SCRIPT_TO_EXECUTE",nullable=true)
    public void setScriptToExecute(String scriptToExecute) {
        this.scriptToExecute = scriptToExecute;
    }

    @Column(name="SCRIPT_TO_EXECUTE",nullable=true)
    public String getScriptToExecute() {
        return scriptToExecute;
    }

	@Transient
    public void setPlannedStartime(String plannedStartTime) throws ParseException {
    	SimpleDateFormat formatter = new SimpleDateFormat(dateFormat);
		if (plannedStartTime.equals(NOW)){
				this.plannedStartTime = new Date();
		}else {
				this.plannedStartTime = formatter.parse(plannedStartTime);
		}
     }

    @Transient
    public void setStartime(String startTime) throws ParseException {
    	SimpleDateFormat formatter = new SimpleDateFormat(dateFormat);
		if (startTime.equals(NOW)){
				this.startTime = new Date();
		}else {
				this.startTime = formatter.parse(startTime);
		}
     }
        
    @Transient
    public void setEndTime(String endTime) throws ParseException {
    	SimpleDateFormat formatter = new SimpleDateFormat(dateFormat);
		if (endTime.equals(NOW)){
				this.endTime = new Date();
		}else {
				this.endTime = formatter.parse(endTime);
		}
     }
        
    
    
	@Transient
	public String getTitle() {
		return  this.uuid  + "/" + this.jobnetNodeDBItem.getSchedulerId() + ":" + this.jobnetNodeDBItem.getJobnet() + ":" + this.jobnetNodeDBItem.getNode() +":" + this.nodeId; 
	}
	
	@Transient
	public String getIdentifier() {
	   return getTitle();
	}

    @Transient 
    public String getPlannedStartTimeFormated(){
        return getDateFormatted(this.plannedStartTime);
    }
    
    @Transient 
    public String getStartTimeFormated(){
        return getDateFormatted(this.startTime);
    }
    
    @Transient 
    public String getEndTimeFormated(){
        return getDateFormatted(this.endTime);
    }
    
    
   @Transient
   @Override
   public INodesItem getJobnetNodeItem() {
       return getJobnetNodeDBItem();
   }
   
  @Transient
  @Override
  public Long getLogId() {
      return taskId;
  }

    
    @Transient
    public boolean isJob() {
        return this.nodeType.equalsIgnoreCase("JOB");
    }
    
    @Transient
    public boolean isConnector() {
        return this.nodeType.equalsIgnoreCase("CONNECTOR");
    }

    @Transient
    public boolean isSubnet() {
        return this.nodeType.equalsIgnoreCase("SUBNET");
    }
    
    
  
	
}
